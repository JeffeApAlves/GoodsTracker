<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GoodsTracker: AdcLdd1 module documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GoodsTracker
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AdcLdd1 module documentation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_adc_ldd1___t_device_data.html">AdcLdd1_TDeviceData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae667536b042ed10bbf59a6ab655e2520"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gae667536b042ed10bbf59a6ab655e2520">AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK</a>&#160;&#160;&#160;(<a class="el" href="group___p_e___types__module.html#ga68b9b7285d322b045dc99ae29c120b7d">LDD_ADC_CHANNEL_0_PIN</a> | <a class="el" href="group___p_e___types__module.html#ga3281a80161f65f2886a42af1564edcda">LDD_ADC_CHANNEL_1_PIN</a>)</td></tr>
<tr class="separator:gae667536b042ed10bbf59a6ab655e2520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e2c2c848190a43f723097450d2bd44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga76e2c2c848190a43f723097450d2bd44">AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK</a>&#160;&#160;&#160;0x00U</td></tr>
<tr class="separator:ga76e2c2c848190a43f723097450d2bd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9364f8d60a68e5f5546eb5bf87436569"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga9364f8d60a68e5f5546eb5bf87436569">AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK</a>&#160;&#160;&#160;0x00U</td></tr>
<tr class="separator:ga9364f8d60a68e5f5546eb5bf87436569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c6c07d48741426405776dfc62732a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga42c6c07d48741426405776dfc62732a6">AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK</a>&#160;&#160;&#160;(<a class="el" href="group___p_e___types__module.html#ga2aca9e4004ca4eb785f08bd3c07c7f8a">LDD_ADC_LOW_VOLT_REF_PIN</a> | <a class="el" href="group___p_e___types__module.html#ga1c613e5f56972bb45b94fa9d272f9589">LDD_ADC_HIGH_VOLT_REF_PIN</a>)</td></tr>
<tr class="separator:ga42c6c07d48741426405776dfc62732a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d69dbadf1bf96582b0bc8677162cadf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga7d69dbadf1bf96582b0bc8677162cadf">AdcLdd1_PRPH_BASE_ADDRESS</a>&#160;&#160;&#160;0x4003B000U</td></tr>
<tr class="separator:ga7d69dbadf1bf96582b0bc8677162cadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d23fa753cfb435ad0ecc28c582987e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga49d23fa753cfb435ad0ecc28c582987e">AdcLdd1_Init_METHOD_ENABLED</a></td></tr>
<tr class="separator:ga49d23fa753cfb435ad0ecc28c582987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2efa18f3ace8958bffdf8bcfbea8034"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gaf2efa18f3ace8958bffdf8bcfbea8034">AdcLdd1_StartSingleMeasurement_METHOD_ENABLED</a></td></tr>
<tr class="separator:gaf2efa18f3ace8958bffdf8bcfbea8034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8248dbbc82166f5d84209b42574e893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gac8248dbbc82166f5d84209b42574e893">AdcLdd1_CancelMeasurement_METHOD_ENABLED</a></td></tr>
<tr class="separator:gac8248dbbc82166f5d84209b42574e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4336debe2c49b40ec5cf443ebdc14fd4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga4336debe2c49b40ec5cf443ebdc14fd4">AdcLdd1_GetMeasuredValues_METHOD_ENABLED</a></td></tr>
<tr class="separator:ga4336debe2c49b40ec5cf443ebdc14fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb31af9978aad248d5f22efeffdc062"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga3bb31af9978aad248d5f22efeffdc062">AdcLdd1_CreateSampleGroup_METHOD_ENABLED</a></td></tr>
<tr class="separator:ga3bb31af9978aad248d5f22efeffdc062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b50f914a3fc9d61298427cfc2e2eba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gaa5b50f914a3fc9d61298427cfc2e2eba">AdcLdd1_GetMeasurementCompleteStatus_METHOD_ENABLED</a></td></tr>
<tr class="separator:gaa5b50f914a3fc9d61298427cfc2e2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac899fcf8121917ba023d530d404521fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gac899fcf8121917ba023d530d404521fe">AdcLdd1_StartCalibration_METHOD_ENABLED</a></td></tr>
<tr class="separator:gac899fcf8121917ba023d530d404521fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3434a6cf32cd48ee67a1a47fb5f91547"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga3434a6cf32cd48ee67a1a47fb5f91547">AdcLdd1_GetCalibrationResultStatus_METHOD_ENABLED</a></td></tr>
<tr class="separator:ga3434a6cf32cd48ee67a1a47fb5f91547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c863eb6c996c95ecf9e799fd5819e89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga5c863eb6c996c95ecf9e799fd5819e89">AdcLdd1_OnMeasurementComplete_EVENT_ENABLED</a></td></tr>
<tr class="separator:ga5c863eb6c996c95ecf9e799fd5819e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8922b556b79ff448ddd20979eda016d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gaa8922b556b79ff448ddd20979eda016d">AdcLdd1_ADC_RESOLUTION</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:gaa8922b556b79ff448ddd20979eda016d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd3f1eef1222a8b6fd2b9f83736a49a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga1fd3f1eef1222a8b6fd2b9f83736a49a">AdcLdd1_CHANNEL_COUNT</a>&#160;&#160;&#160;2u</td></tr>
<tr class="separator:ga1fd3f1eef1222a8b6fd2b9f83736a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d870f5e63fbe60a4c8ed64bb54faebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga7d870f5e63fbe60a4c8ed64bb54faebc">AdcLdd1_NO_CHANNEL</a>&#160;&#160;&#160;0x1FU</td></tr>
<tr class="separator:ga7d870f5e63fbe60a4c8ed64bb54faebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2218fd28c1cf32594ae2bac6a091cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga0b2218fd28c1cf32594ae2bac6a091cb">AdcLdd1_MAX_HW_SAMPLE_COUNT</a>&#160;&#160;&#160;1U</td></tr>
<tr class="separator:ga0b2218fd28c1cf32594ae2bac6a091cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f18908164f6c6b8b8ccefa8b01c87b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga84f18908164f6c6b8b8ccefa8b01c87b">AdcLdd1_RESULT_WIDTH</a>&#160;&#160;&#160;16U</td></tr>
<tr class="separator:ga84f18908164f6c6b8b8ccefa8b01c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7f6957bdc1b4d8a3cb7df4f0e50a88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gabe7f6957bdc1b4d8a3cb7df4f0e50a88">AdcLdd1_RESULT_WIDTH_BYTES</a>&#160;&#160;&#160;2U</td></tr>
<tr class="separator:gabe7f6957bdc1b4d8a3cb7df4f0e50a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f9b5507ee5e9a1d531867951d1ded9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga57f9b5507ee5e9a1d531867951d1ded9">AdcLdd1_RESULT_TYPE_UNSIGNED</a></td></tr>
<tr class="separator:ga57f9b5507ee5e9a1d531867951d1ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabc048953ad953bc16463d49d94832206"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_adc_ldd1___t_device_data.html">AdcLdd1_TDeviceData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gabc048953ad953bc16463d49d94832206">AdcLdd1_TDeviceDataPtr</a></td></tr>
<tr class="separator:gabc048953ad953bc16463d49d94832206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eae0d930b3aef7c47506b32a22e4f12"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga8eae0d930b3aef7c47506b32a22e4f12">AdcLdd1_TResultData</a></td></tr>
<tr class="separator:ga8eae0d930b3aef7c47506b32a22e4f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafdc37e93f468b5be237479085546273f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gafdc37e93f468b5be237479085546273f">AdcLdd1_Init</a> (<a class="el" href="group___p_e___types__module.html#ga0b66a73f87238a782318aa0be7578e35">LDD_TUserData</a> *UserDataPtr)</td></tr>
<tr class="memdesc:gafdc37e93f468b5be237479085546273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated. This method can be called only once. Before the second call of Init() the Deinit() must be called first.  <a href="#gafdc37e93f468b5be237479085546273f">More...</a><br /></td></tr>
<tr class="separator:gafdc37e93f468b5be237479085546273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00728ff1e652d8d8d778917ca27e37a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga00728ff1e652d8d8d778917ca27e37a1">AdcLdd1_StartSingleMeasurement</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr)</td></tr>
<tr class="memdesc:ga00728ff1e652d8d8d778917ca27e37a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts one measurement of the selected group of samples and exits immediately. This is ADC SW trigger method. The group of samples for measurement is specified by preceding call to [SelectSampleGroup()] or [CreateSampleGroup] method. DMA disabled: The [OnMeasurementComplete() ] event is invoked after the measurement is done and if the event is enabled. Results of the measurement can be read by the [GetMeasuredValues()] method. DMA enabled: DMA request from configured ADC is enabled automatically. The [OnMeasurementComplete() ] event is invoked after the requested number of results are transferred to destination buffer by DMA and if the event is enabled. [GetMeasuredValues()] method is not available if DMA mode is enabled. If the DMA transfer was completed before and DMA is not recofingured, DMA error can occur. See also [SetBuffer()] method. The state of the measurement can be also polled by the [GetMeasurementCompleteStatus()] method. The [Discontinuous mode] doesn't support this method.  <a href="#ga00728ff1e652d8d8d778917ca27e37a1">More...</a><br /></td></tr>
<tr class="separator:ga00728ff1e652d8d8d778917ca27e37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26924e7e4ca2c272140fbaf6ecf9c18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga26924e7e4ca2c272140fbaf6ecf9c18d">AdcLdd1_CancelMeasurement</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr)</td></tr>
<tr class="memdesc:ga26924e7e4ca2c272140fbaf6ecf9c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method cancels the measurement in progress. Typically the OnMeasurementComplete() event is not invoked for cancelled measurement. If DMA mode is enabled, DMA request from ADC is disabled and DMA transfer is cancelled.  <a href="#ga26924e7e4ca2c272140fbaf6ecf9c18d">More...</a><br /></td></tr>
<tr class="separator:ga26924e7e4ca2c272140fbaf6ecf9c18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86203c058acad0397b653ce3a4a625a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga86203c058acad0397b653ce3a4a625a4">AdcLdd1_CreateSampleGroup</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr, <a class="el" href="struct_l_d_d___a_d_c___t_sample.html">LDD_ADC_TSample</a> *SampleGroupPtr, uint8_t SampleCount)</td></tr>
<tr class="memdesc:ga86203c058acad0397b653ce3a4a625a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method prepares HW for next measurement according to array of samples defined during run-time. The array of samples should be prepared prior to calling this method. Pointer to the array is passed into this method in parameter SampleGroupPtr. The number of samples is defined by parameter SampleCount. Once any group is prepared, the measurement can be started multiple times. Note: This method works only with the sample groups defined during run-time. For design-time defined groups use [SelectSampleGroup()] method.  <a href="#ga86203c058acad0397b653ce3a4a625a4">More...</a><br /></td></tr>
<tr class="separator:ga86203c058acad0397b653ce3a4a625a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30f524b93639b958a529d6f91c41ce6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga30f524b93639b958a529d6f91c41ce6d">AdcLdd1_GetMeasuredValues</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr, <a class="el" href="group___p_e___types__module.html#gade8ef9401405bd941b6da738b807f980">LDD_TData</a> *BufferPtr)</td></tr>
<tr class="memdesc:ga30f524b93639b958a529d6f91c41ce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method copies results of the last measurement to the user supplied buffer. Data size depends on the size of measured sample group (see [SelectSampleGroup()] or [CreateSampleGroup()] method). Data representation is defined by the [Result type] property. Typically this method is called from [OnMeasurementComplete] event to get results of the last measurement. This method is not available if DMA is enabled.  <a href="#ga30f524b93639b958a529d6f91c41ce6d">More...</a><br /></td></tr>
<tr class="separator:ga30f524b93639b958a529d6f91c41ce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df44002c6ba3479f104deedd98b7e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga4df44002c6ba3479f104deedd98b7e4e">AdcLdd1_GetMeasurementCompleteStatus</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr)</td></tr>
<tr class="memdesc:ga4df44002c6ba3479f104deedd98b7e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the measurement is done and the results can be read by the user. It can be used to poll the state of measurement if [Interrupt service/event] is disabled or if [OnMeasurementComplete] event is disabled by the [SetEventMask()] methods.  <a href="#ga4df44002c6ba3479f104deedd98b7e4e">More...</a><br /></td></tr>
<tr class="separator:ga4df44002c6ba3479f104deedd98b7e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d49b5f1a7ef34cde56046754ebb62a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gab9d49b5f1a7ef34cde56046754ebb62a">AdcLdd1_StartCalibration</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr)</td></tr>
<tr class="memdesc:gab9d49b5f1a7ef34cde56046754ebb62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts self calibration process. Calibration is typically used to remove the effects of the gain and offset from a specific reading.  <a href="#gab9d49b5f1a7ef34cde56046754ebb62a">More...</a><br /></td></tr>
<tr class="separator:gab9d49b5f1a7ef34cde56046754ebb62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec76afa5d4906636d7b7acd8a4008d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#gaeec76afa5d4906636d7b7acd8a4008d3">AdcLdd1_GetCalibrationResultStatus</a> (<a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *DeviceDataPtr)</td></tr>
<tr class="memdesc:gaeec76afa5d4906636d7b7acd8a4008d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should be used for check the last calibration result. If calibration completed normally the method finish calibration process by writing gain calibration values.  <a href="#gaeec76afa5d4906636d7b7acd8a4008d3">More...</a><br /></td></tr>
<tr class="separator:gaeec76afa5d4906636d7b7acd8a4008d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563031e4594799f73a2a64dbdc65ea00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___adc_ldd1__module.html#ga563031e4594799f73a2a64dbdc65ea00">PE_ISR</a> (AdcLdd1_MeasurementCompleteInterrupt)</td></tr>
<tr class="separator:ga563031e4594799f73a2a64dbdc65ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa8922b556b79ff448ddd20979eda016d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8922b556b79ff448ddd20979eda016d">&#9670;&nbsp;</a></span>AdcLdd1_ADC_RESOLUTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_ADC_RESOLUTION&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae667536b042ed10bbf59a6ab655e2520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae667536b042ed10bbf59a6ab655e2520">&#9670;&nbsp;</a></span>AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK&#160;&#160;&#160;(<a class="el" href="group___p_e___types__module.html#ga68b9b7285d322b045dc99ae29c120b7d">LDD_ADC_CHANNEL_0_PIN</a> | <a class="el" href="group___p_e___types__module.html#ga3281a80161f65f2886a42af1564edcda">LDD_ADC_CHANNEL_1_PIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask of all allocated channel pins from 0 to 31 </p>

</div>
</div>
<a id="ga76e2c2c848190a43f723097450d2bd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e2c2c848190a43f723097450d2bd44">&#9670;&nbsp;</a></span>AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK&#160;&#160;&#160;0x00U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask of all allocated channel pins from 32 to 63 </p>

</div>
</div>
<a id="ga9364f8d60a68e5f5546eb5bf87436569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9364f8d60a68e5f5546eb5bf87436569">&#9670;&nbsp;</a></span>AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK&#160;&#160;&#160;0x00U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask of all allocated trigger pins </p>

</div>
</div>
<a id="ga42c6c07d48741426405776dfc62732a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42c6c07d48741426405776dfc62732a6">&#9670;&nbsp;</a></span>AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK&#160;&#160;&#160;(<a class="el" href="group___p_e___types__module.html#ga2aca9e4004ca4eb785f08bd3c07c7f8a">LDD_ADC_LOW_VOLT_REF_PIN</a> | <a class="el" href="group___p_e___types__module.html#ga1c613e5f56972bb45b94fa9d272f9589">LDD_ADC_HIGH_VOLT_REF_PIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask of all allocated voltage reference pins </p>

</div>
</div>
<a id="gac8248dbbc82166f5d84209b42574e893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8248dbbc82166f5d84209b42574e893">&#9670;&nbsp;</a></span>AdcLdd1_CancelMeasurement_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_CancelMeasurement_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CancelMeasurement method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga1fd3f1eef1222a8b6fd2b9f83736a49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fd3f1eef1222a8b6fd2b9f83736a49a">&#9670;&nbsp;</a></span>AdcLdd1_CHANNEL_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_CHANNEL_COUNT&#160;&#160;&#160;2u</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3bb31af9978aad248d5f22efeffdc062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb31af9978aad248d5f22efeffdc062">&#9670;&nbsp;</a></span>AdcLdd1_CreateSampleGroup_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_CreateSampleGroup_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CreateSampleGroup method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga3434a6cf32cd48ee67a1a47fb5f91547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3434a6cf32cd48ee67a1a47fb5f91547">&#9670;&nbsp;</a></span>AdcLdd1_GetCalibrationResultStatus_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_GetCalibrationResultStatus_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GetCalibrationResultStatus method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga4336debe2c49b40ec5cf443ebdc14fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4336debe2c49b40ec5cf443ebdc14fd4">&#9670;&nbsp;</a></span>AdcLdd1_GetMeasuredValues_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_GetMeasuredValues_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GetMeasuredValues method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="gaa5b50f914a3fc9d61298427cfc2e2eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b50f914a3fc9d61298427cfc2e2eba">&#9670;&nbsp;</a></span>AdcLdd1_GetMeasurementCompleteStatus_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_GetMeasurementCompleteStatus_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GetMeasurementCompleteStatus method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga49d23fa753cfb435ad0ecc28c582987e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d23fa753cfb435ad0ecc28c582987e">&#9670;&nbsp;</a></span>AdcLdd1_Init_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_Init_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga0b2218fd28c1cf32594ae2bac6a091cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2218fd28c1cf32594ae2bac6a091cb">&#9670;&nbsp;</a></span>AdcLdd1_MAX_HW_SAMPLE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_MAX_HW_SAMPLE_COUNT&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7d870f5e63fbe60a4c8ed64bb54faebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d870f5e63fbe60a4c8ed64bb54faebc">&#9670;&nbsp;</a></span>AdcLdd1_NO_CHANNEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_NO_CHANNEL&#160;&#160;&#160;0x1FU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5c863eb6c996c95ecf9e799fd5819e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c863eb6c996c95ecf9e799fd5819e89">&#9670;&nbsp;</a></span>AdcLdd1_OnMeasurementComplete_EVENT_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_OnMeasurementComplete_EVENT_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OnMeasurementComplete event of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="ga7d69dbadf1bf96582b0bc8677162cadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d69dbadf1bf96582b0bc8677162cadf">&#9670;&nbsp;</a></span>AdcLdd1_PRPH_BASE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_PRPH_BASE_ADDRESS&#160;&#160;&#160;0x4003B000U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Peripheral base address of a device allocated by the component. This constant can be used directly in PDD macros. </p>

</div>
</div>
<a id="ga57f9b5507ee5e9a1d531867951d1ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57f9b5507ee5e9a1d531867951d1ded9">&#9670;&nbsp;</a></span>AdcLdd1_RESULT_TYPE_UNSIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_RESULT_TYPE_UNSIGNED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga84f18908164f6c6b8b8ccefa8b01c87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84f18908164f6c6b8b8ccefa8b01c87b">&#9670;&nbsp;</a></span>AdcLdd1_RESULT_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_RESULT_WIDTH&#160;&#160;&#160;16U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabe7f6957bdc1b4d8a3cb7df4f0e50a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7f6957bdc1b4d8a3cb7df4f0e50a88">&#9670;&nbsp;</a></span>AdcLdd1_RESULT_WIDTH_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_RESULT_WIDTH_BYTES&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac899fcf8121917ba023d530d404521fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac899fcf8121917ba023d530d404521fe">&#9670;&nbsp;</a></span>AdcLdd1_StartCalibration_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_StartCalibration_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>StartCalibration method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<a id="gaf2efa18f3ace8958bffdf8bcfbea8034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2efa18f3ace8958bffdf8bcfbea8034">&#9670;&nbsp;</a></span>AdcLdd1_StartSingleMeasurement_METHOD_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AdcLdd1_StartSingleMeasurement_METHOD_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>StartSingleMeasurement method of the component AdcLdd1 is enabled (generated) </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gabc048953ad953bc16463d49d94832206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc048953ad953bc16463d49d94832206">&#9670;&nbsp;</a></span>AdcLdd1_TDeviceDataPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_adc_ldd1___t_device_data.html">AdcLdd1_TDeviceData</a>* <a class="el" href="group___adc_ldd1__module.html#gabc048953ad953bc16463d49d94832206">AdcLdd1_TDeviceDataPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8eae0d930b3aef7c47506b32a22e4f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eae0d930b3aef7c47506b32a22e4f12">&#9670;&nbsp;</a></span>AdcLdd1_TResultData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group___adc_ldd1__module.html#ga8eae0d930b3aef7c47506b32a22e4f12">AdcLdd1_TResultData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga26924e7e4ca2c272140fbaf6ecf9c18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26924e7e4ca2c272140fbaf6ecf9c18d">&#9670;&nbsp;</a></span>AdcLdd1_CancelMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_CancelMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method cancels the measurement in progress. Typically the OnMeasurementComplete() event is not invoked for cancelled measurement. If DMA mode is enabled, DMA request from ADC is disabled and DMA transfer is cancelled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code, possible codes: ERR_OK - OK ERR_SPEED - The device doesn't work in the active clock configuration ERR_DISABLED - Component is disabled </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga86203c058acad0397b653ce3a4a625a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86203c058acad0397b653ce3a4a625a4">&#9670;&nbsp;</a></span>AdcLdd1_CreateSampleGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_CreateSampleGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_l_d_d___a_d_c___t_sample.html">LDD_ADC_TSample</a> *&#160;</td>
          <td class="paramname"><em>SampleGroupPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>SampleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method prepares HW for next measurement according to array of samples defined during run-time. The array of samples should be prepared prior to calling this method. Pointer to the array is passed into this method in parameter SampleGroupPtr. The number of samples is defined by parameter SampleCount. Once any group is prepared, the measurement can be started multiple times. Note: This method works only with the sample groups defined during run-time. For design-time defined groups use [SelectSampleGroup()] method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
    <tr><td class="paramname">SampleGroupPtr</td><td>- Pointer to the sample definition array. This array can be released as soon as the method ends. </td></tr>
    <tr><td class="paramname">SampleCount</td><td>- Number of items in the sample definition array. Must be less than or equal to ComponentName_MAX_HW_SAMPLE_COUNT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code, possible codes: ERR_OK - OK ERR_SPEED - The device doesn't work in the active clock configuration ERR_DISABLED - Component is disabled ERR_PARAM_INDEX - Channel index in SampleGroup structure is out of range ERR_PARAM_SAMPLE_COUNT - SampleCount variable value is out of range ERR_BUSY - Measurement is in progress </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeec76afa5d4906636d7b7acd8a4008d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec76afa5d4906636d7b7acd8a4008d3">&#9670;&nbsp;</a></span>AdcLdd1_GetCalibrationResultStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_GetCalibrationResultStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method should be used for check the last calibration result. If calibration completed normally the method finish calibration process by writing gain calibration values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code ERR_OK - OK ERR_FAILED - Last calibration hasn't been finished correctly </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___adc_ldd1__module_gaeec76afa5d4906636d7b7acd8a4008d3_icgraph.png" border="0" usemap="#group___adc_ldd1__module_gaeec76afa5d4906636d7b7acd8a4008d3_icgraph" alt=""/></div>
<!-- MAP 0 -->
</div>

</div>
</div>
<a id="ga30f524b93639b958a529d6f91c41ce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30f524b93639b958a529d6f91c41ce6d">&#9670;&nbsp;</a></span>AdcLdd1_GetMeasuredValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_GetMeasuredValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gade8ef9401405bd941b6da738b807f980">LDD_TData</a> *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method copies results of the last measurement to the user supplied buffer. Data size depends on the size of measured sample group (see [SelectSampleGroup()] or [CreateSampleGroup()] method). Data representation is defined by the [Result type] property. Typically this method is called from [OnMeasurementComplete] event to get results of the last measurement. This method is not available if DMA is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>- Pointer to the start of the buffer for new results. Count of stored measured values equals to the count of the samples in the active sample group. It is in the user responsibility to provide buffer with appropriate size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code, possible codes: ERR_OK - OK ERR_SPEED - The device doesn't work in the active clock configuration ERR_DISABLED - Component is disabled </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___adc_ldd1__module_ga30f524b93639b958a529d6f91c41ce6d_icgraph.png" border="0" usemap="#group___adc_ldd1__module_ga30f524b93639b958a529d6f91c41ce6d_icgraph" alt=""/></div>
<!-- MAP 1 -->
</div>

</div>
</div>
<a id="ga4df44002c6ba3479f104deedd98b7e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df44002c6ba3479f104deedd98b7e4e">&#9670;&nbsp;</a></span>AdcLdd1_GetMeasurementCompleteStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga97a80ca1602ebf2303258971a2c938e2">bool</a> AdcLdd1_GetMeasurementCompleteStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the measurement is done and the results can be read by the user. It can be used to poll the state of measurement if [Interrupt service/event] is disabled or if [OnMeasurementComplete] event is disabled by the [SetEventMask()] methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code true - Measurement is done false - Measurement is in progress </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___adc_ldd1__module_ga4df44002c6ba3479f104deedd98b7e4e_icgraph.png" border="0" usemap="#group___adc_ldd1__module_ga4df44002c6ba3479f104deedd98b7e4e_icgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="gafdc37e93f468b5be237479085546273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdc37e93f468b5be237479085546273f">&#9670;&nbsp;</a></span>AdcLdd1_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> * AdcLdd1_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#ga0b66a73f87238a782318aa0be7578e35">LDD_TUserData</a> *&#160;</td>
          <td class="paramname"><em>UserDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated. This method can be called only once. Before the second call of Init() the Deinit() must be called first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserDataPtr</td><td>- Pointer to the user or RTOS specific data. This pointer will be passed as an event or callback parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Device data structure pointer. </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___adc_ldd1__module_gafdc37e93f468b5be237479085546273f_icgraph.png" border="0" usemap="#group___adc_ldd1__module_gafdc37e93f468b5be237479085546273f_icgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="gab9d49b5f1a7ef34cde56046754ebb62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9d49b5f1a7ef34cde56046754ebb62a">&#9670;&nbsp;</a></span>AdcLdd1_StartCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_StartCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method starts self calibration process. Calibration is typically used to remove the effects of the gain and offset from a specific reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code ERR_OK - OK ERR_SPEED - The device doesn't work in the active clock configuration ERR_DISABLED - Component is disabled ERR_BUSY - A conversion is already running </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___adc_ldd1__module_gab9d49b5f1a7ef34cde56046754ebb62a_icgraph.png" border="0" usemap="#group___adc_ldd1__module_gab9d49b5f1a7ef34cde56046754ebb62a_icgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="ga00728ff1e652d8d8d778917ca27e37a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00728ff1e652d8d8d778917ca27e37a1">&#9670;&nbsp;</a></span>AdcLdd1_StartSingleMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_e___types__module.html#ga24c2b045fd04e79e85f261ce4df35588">LDD_TError</a> AdcLdd1_StartSingleMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_e___types__module.html#gac5cf1362f1f0e3a2ce71b1bf2276d091">LDD_TDeviceData</a> *&#160;</td>
          <td class="paramname"><em>DeviceDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method starts one measurement of the selected group of samples and exits immediately. This is ADC SW trigger method. The group of samples for measurement is specified by preceding call to [SelectSampleGroup()] or [CreateSampleGroup] method. DMA disabled: The [OnMeasurementComplete() ] event is invoked after the measurement is done and if the event is enabled. Results of the measurement can be read by the [GetMeasuredValues()] method. DMA enabled: DMA request from configured ADC is enabled automatically. The [OnMeasurementComplete() ] event is invoked after the requested number of results are transferred to destination buffer by DMA and if the event is enabled. [GetMeasuredValues()] method is not available if DMA mode is enabled. If the DMA transfer was completed before and DMA is not recofingured, DMA error can occur. See also [SetBuffer()] method. The state of the measurement can be also polled by the [GetMeasurementCompleteStatus()] method. The [Discontinuous mode] doesn't support this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceDataPtr</td><td>- Device data structure pointer returned by [Init] method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Error code, possible codes: ERR_OK - OK ERR_SPEED - The device doesn't work in the active clock configuration ERR_DISABLED - Component is disabled ERR_BUSY - A measurement is in progress </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga563031e4594799f73a2a64dbdc65ea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563031e4594799f73a2a64dbdc65ea00">&#9670;&nbsp;</a></span>PE_ISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PE_ISR </td>
          <td>(</td>
          <td class="paramtype">AdcLdd1_MeasurementCompleteInterrupt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
