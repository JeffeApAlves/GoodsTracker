<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GoodsTracker: F:/workspace/GoodsTracker/platform/GoodsTrackerControl/Static_Code/PDD/RTC_PDD.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GoodsTracker
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c5a52a81292cf9a5167198f4f346d6d9.html">platform</a></li><li class="navelem"><a class="el" href="dir_0bbc1acbef512845ac42e815d7a45fcb.html">GoodsTrackerControl</a></li><li class="navelem"><a class="el" href="dir_3566e7a2574f94e2642f2ebc744ea463.html">Static_Code</a></li><li class="navelem"><a class="el" href="dir_c69feab5debe2620e41ce024c3468f87.html">PDD</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">RTC_PDD.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_p_d_d___types_8h_source.html">PDD_Types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for RTC_PDD.h:</div>
<div class="dyncontent">
<div class="center"><img src="_r_t_c___p_d_d_8h__incl.png" border="0" usemap="#_f_1_2workspace_2_goods_tracker_2platform_2_goods_tracker_control_2_static___code_2_p_d_d_2_r_t_c___p_d_d_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_r_t_c___p_d_d_8h__dep__incl.png" border="0" usemap="#_f_1_2workspace_2_goods_tracker_2platform_2_goods_tracker_control_2_static___code_2_p_d_d_2_r_t_c___p_d_d_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="_r_t_c___p_d_d_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a46506be665e801685a1d8d68e38a053d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a46506be665e801685a1d8d68e38a053d">RTC_PDD_TAF_INT</a>&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#ga8deec41a2823788375ed7b8b63870868">RTC_SR_TAF_MASK</a></td></tr>
<tr class="separator:a46506be665e801685a1d8d68e38a053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91213da44685a41539f7f391cf7be9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#af91213da44685a41539f7f391cf7be9a">RTC_PDD_TOF_INT</a>&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#gabadca56816c485ca12134cd54a40c010">RTC_SR_TOF_MASK</a></td></tr>
<tr class="separator:af91213da44685a41539f7f391cf7be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4f80ec20cc1734201d7cecd5260ace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#abb4f80ec20cc1734201d7cecd5260ace">RTC_PDD_TIF_INT</a>&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#ga1efc73171f80fa079f4d3aec43f2faab">RTC_SR_TIF_MASK</a></td></tr>
<tr class="separator:abb4f80ec20cc1734201d7cecd5260ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446474896e80e98138910c35f603437a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a446474896e80e98138910c35f603437a">RTC_PDD_TMF_INT</a>&#160;&#160;&#160;RTC_TDR_TMF_MASK</td></tr>
<tr class="separator:a446474896e80e98138910c35f603437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5945ae44076fa558f026d928bd71cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8f5945ae44076fa558f026d928bd71cf">RTC_PDD_FSF_INT</a>&#160;&#160;&#160;RTC_TDR_FSF_MASK</td></tr>
<tr class="separator:a8f5945ae44076fa558f026d928bd71cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef84c5a6ca4b9713e11364b39decc3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aaef84c5a6ca4b9713e11364b39decc3a">RTC_PDD_TTF_INT</a>&#160;&#160;&#160;RTC_TDR_TTF_MASK</td></tr>
<tr class="separator:aaef84c5a6ca4b9713e11364b39decc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa611383e95284c75839569bb3bd58195"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aa611383e95284c75839569bb3bd58195">RTC_PDD_CTF_INT</a>&#160;&#160;&#160;RTC_TDR_CTF_MASK</td></tr>
<tr class="separator:aa611383e95284c75839569bb3bd58195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f4482580fbc9919e18af00e8241d86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aa9f4482580fbc9919e18af00e8241d86">RTC_PDD_VTF_INT</a>&#160;&#160;&#160;RTC_TDR_VTF_MASK</td></tr>
<tr class="separator:aa9f4482580fbc9919e18af00e8241d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c7f7b278d0a3ced9facc2733e17ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ae25c7f7b278d0a3ced9facc2733e17ca">RTC_PDD_DTF_INT</a>&#160;&#160;&#160;RTC_TDR_DTF_MASK</td></tr>
<tr class="separator:ae25c7f7b278d0a3ced9facc2733e17ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63cd9f06582f50609a7450f7072e21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0e63cd9f06582f50609a7450f7072e21">RTC_PDD_ASSERTED</a>&#160;&#160;&#160;0x8U</td></tr>
<tr class="separator:a0e63cd9f06582f50609a7450f7072e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab384f783d6acffcf3ca2fbd99bd01430"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ab384f783d6acffcf3ca2fbd99bd01430">RTC_PDD_NOT_ASSERTED</a>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:ab384f783d6acffcf3ca2fbd99bd01430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ba39ebe33db3dd9f62a96b7d6b186a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aa2ba39ebe33db3dd9f62a96b7d6b186a">RTC_PDD_ReadTimeSecondsReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aa2ba39ebe33db3dd9f62a96b7d6b186a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Time seconds register.  <a href="#aa2ba39ebe33db3dd9f62a96b7d6b186a">More...</a><br /></td></tr>
<tr class="separator:aa2ba39ebe33db3dd9f62a96b7d6b186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c87ce278c703cc5cdf0cf5a657f6f16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a3c87ce278c703cc5cdf0cf5a657f6f16">RTC_PDD_WriteTimeSecondsReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a3c87ce278c703cc5cdf0cf5a657f6f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Time seconds register.  <a href="#a3c87ce278c703cc5cdf0cf5a657f6f16">More...</a><br /></td></tr>
<tr class="separator:a3c87ce278c703cc5cdf0cf5a657f6f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7aa88a1eca9a0a4a8a7230dcf230a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2e7aa88a1eca9a0a4a8a7230dcf230a6">RTC_PDD_ReadTimePrescalerReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2e7aa88a1eca9a0a4a8a7230dcf230a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Time prescaler register.  <a href="#a2e7aa88a1eca9a0a4a8a7230dcf230a6">More...</a><br /></td></tr>
<tr class="separator:a2e7aa88a1eca9a0a4a8a7230dcf230a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b9f51c8504efe26e8037a7839e074b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a54b9f51c8504efe26e8037a7839e074b">RTC_PDD_WriteTimePrescalerReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a54b9f51c8504efe26e8037a7839e074b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Time prescaler register.  <a href="#a54b9f51c8504efe26e8037a7839e074b">More...</a><br /></td></tr>
<tr class="separator:a54b9f51c8504efe26e8037a7839e074b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee012d50e404ede78f52b01af76fe4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0ee012d50e404ede78f52b01af76fe4b">RTC_PDD_ReadTimeAlarmReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a0ee012d50e404ede78f52b01af76fe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Time alarm register.  <a href="#a0ee012d50e404ede78f52b01af76fe4b">More...</a><br /></td></tr>
<tr class="separator:a0ee012d50e404ede78f52b01af76fe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bec7545b99e206c42d8673e0705de6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a4bec7545b99e206c42d8673e0705de6d">RTC_PDD_WriteTimeAlarmReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a4bec7545b99e206c42d8673e0705de6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Time alarm register.  <a href="#a4bec7545b99e206c42d8673e0705de6d">More...</a><br /></td></tr>
<tr class="separator:a4bec7545b99e206c42d8673e0705de6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f0a9a5f92353e131c8c29acf4a6dcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a07f0a9a5f92353e131c8c29acf4a6dcf">RTC_PDD_ReadTimeCompensationReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a07f0a9a5f92353e131c8c29acf4a6dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Time compensation register.  <a href="#a07f0a9a5f92353e131c8c29acf4a6dcf">More...</a><br /></td></tr>
<tr class="separator:a07f0a9a5f92353e131c8c29acf4a6dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1d27bf8728764eb2ad52bd0576c12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#afcf1d27bf8728764eb2ad52bd0576c12">RTC_PDD_WriteTimeCompensationReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:afcf1d27bf8728764eb2ad52bd0576c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Time compensation register.  <a href="#afcf1d27bf8728764eb2ad52bd0576c12">More...</a><br /></td></tr>
<tr class="separator:afcf1d27bf8728764eb2ad52bd0576c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ea06ba509408063e58c9034c1da9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#af08ea06ba509408063e58c9034c1da9d">RTC_PDD_ReadControlReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:af08ea06ba509408063e58c9034c1da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Control register.  <a href="#af08ea06ba509408063e58c9034c1da9d">More...</a><br /></td></tr>
<tr class="separator:af08ea06ba509408063e58c9034c1da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7a9d9f496bbb5ca0097bc043343c93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a5f7a9d9f496bbb5ca0097bc043343c93">RTC_PDD_WriteControlReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a5f7a9d9f496bbb5ca0097bc043343c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Control register.  <a href="#a5f7a9d9f496bbb5ca0097bc043343c93">More...</a><br /></td></tr>
<tr class="separator:a5f7a9d9f496bbb5ca0097bc043343c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a34d2e72d1a661b4bbccd5fe4be892"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a73a34d2e72d1a661b4bbccd5fe4be892">RTC_PDD_EnableUpdateMode</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:a73a34d2e72d1a661b4bbccd5fe4be892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables update mode.  <a href="#a73a34d2e72d1a661b4bbccd5fe4be892">More...</a><br /></td></tr>
<tr class="separator:a73a34d2e72d1a661b4bbccd5fe4be892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f3e11628daff979b256bda935d46e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a88f3e11628daff979b256bda935d46e7">RTC_PDD_EnableSupervisorAccess</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:a88f3e11628daff979b256bda935d46e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables supervisor accesss.  <a href="#a88f3e11628daff979b256bda935d46e7">More...</a><br /></td></tr>
<tr class="separator:a88f3e11628daff979b256bda935d46e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116eeaa0c821be7394233415fa9dfcdd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a116eeaa0c821be7394233415fa9dfcdd">RTC_PDD_EnableWakeupPin</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:a116eeaa0c821be7394233415fa9dfcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables wakeup pin.  <a href="#a116eeaa0c821be7394233415fa9dfcdd">More...</a><br /></td></tr>
<tr class="separator:a116eeaa0c821be7394233415fa9dfcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4414955b1ed3d7c4fa6bba0d0db31286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a4414955b1ed3d7c4fa6bba0d0db31286">RTC_PDD_ForceSwReset</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a4414955b1ed3d7c4fa6bba0d0db31286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the equivalent of a VBAT POR to the rest of the RTC module, except the access control registers.  <a href="#a4414955b1ed3d7c4fa6bba0d0db31286">More...</a><br /></td></tr>
<tr class="separator:a4414955b1ed3d7c4fa6bba0d0db31286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0efeea9283ff1486c8992190b8d772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#acc0efeea9283ff1486c8992190b8d772">RTC_PDD_GetRtcInterruptMask</a>(PeripheralBase)</td></tr>
<tr class="memdesc:acc0efeea9283ff1486c8992190b8d772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the RTC interrupt enable register.  <a href="#acc0efeea9283ff1486c8992190b8d772">More...</a><br /></td></tr>
<tr class="separator:acc0efeea9283ff1486c8992190b8d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df0941f1d939cbb99ac4c44a7da686"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#af6df0941f1d939cbb99ac4c44a7da686">RTC_PDD_SetRtcInterruptMask</a>(PeripheralBase,  Mask)</td></tr>
<tr class="memdesc:af6df0941f1d939cbb99ac4c44a7da686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables RTC interrupts defined by the Mask parameter.  <a href="#af6df0941f1d939cbb99ac4c44a7da686">More...</a><br /></td></tr>
<tr class="separator:af6df0941f1d939cbb99ac4c44a7da686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52faa25caeec8beb1b16fa433a5fb25c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a52faa25caeec8beb1b16fa433a5fb25c">RTC_PDD_EnableSecondsInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a52faa25caeec8beb1b16fa433a5fb25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Seconds interrupt.  <a href="#a52faa25caeec8beb1b16fa433a5fb25c">More...</a><br /></td></tr>
<tr class="separator:a52faa25caeec8beb1b16fa433a5fb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80139a02f86ce73f0bba4eafa5b3dcd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a80139a02f86ce73f0bba4eafa5b3dcd9">RTC_PDD_EnableAlarmInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a80139a02f86ce73f0bba4eafa5b3dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Alarm interrupt.  <a href="#a80139a02f86ce73f0bba4eafa5b3dcd9">More...</a><br /></td></tr>
<tr class="separator:a80139a02f86ce73f0bba4eafa5b3dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f20eea4f7c38e1ca3a38515a2df3af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ac2f20eea4f7c38e1ca3a38515a2df3af">RTC_PDD_EnableTimeOverflowInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ac2f20eea4f7c38e1ca3a38515a2df3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Time overflow interrupt.  <a href="#ac2f20eea4f7c38e1ca3a38515a2df3af">More...</a><br /></td></tr>
<tr class="separator:ac2f20eea4f7c38e1ca3a38515a2df3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2619e9f0c03f0a59e040a436b1381eac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2619e9f0c03f0a59e040a436b1381eac">RTC_PDD_EnableTimeInvalidInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2619e9f0c03f0a59e040a436b1381eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Time invalid interrupt.  <a href="#a2619e9f0c03f0a59e040a436b1381eac">More...</a><br /></td></tr>
<tr class="separator:a2619e9f0c03f0a59e040a436b1381eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17829684ce4f1f59e655ae847caf9927"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a17829684ce4f1f59e655ae847caf9927">RTC_PDD_DisableSecondsInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a17829684ce4f1f59e655ae847caf9927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Seconds interrupt.  <a href="#a17829684ce4f1f59e655ae847caf9927">More...</a><br /></td></tr>
<tr class="separator:a17829684ce4f1f59e655ae847caf9927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d131732142356708552e11c4beb77cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a4d131732142356708552e11c4beb77cc">RTC_PDD_DisableAlarmInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a4d131732142356708552e11c4beb77cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Alarm interrupt.  <a href="#a4d131732142356708552e11c4beb77cc">More...</a><br /></td></tr>
<tr class="separator:a4d131732142356708552e11c4beb77cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a17d968ee5bf693d38893e9b23cb08a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8a17d968ee5bf693d38893e9b23cb08a">RTC_PDD_DisableTimeOverflowInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a8a17d968ee5bf693d38893e9b23cb08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Time overflow interrupt.  <a href="#a8a17d968ee5bf693d38893e9b23cb08a">More...</a><br /></td></tr>
<tr class="separator:a8a17d968ee5bf693d38893e9b23cb08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6f9549f12d7134e6628a9a952d4d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a3ba6f9549f12d7134e6628a9a952d4d5">RTC_PDD_DisableTimeInvalidInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a3ba6f9549f12d7134e6628a9a952d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Time invalid interrupt.  <a href="#a3ba6f9549f12d7134e6628a9a952d4d5">More...</a><br /></td></tr>
<tr class="separator:a3ba6f9549f12d7134e6628a9a952d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9f2f0305ca3955e36f5b09a0dd2c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad3e9f2f0305ca3955e36f5b09a0dd2c9">RTC_PDD_SetWakeUpPinState</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:ad3e9f2f0305ca3955e36f5b09a0dd2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets wake-up pin state.  <a href="#ad3e9f2f0305ca3955e36f5b09a0dd2c9">More...</a><br /></td></tr>
<tr class="separator:ad3e9f2f0305ca3955e36f5b09a0dd2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad1108af887779b61fedfc47bc127ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#adad1108af887779b61fedfc47bc127ee">RTC_PDD_ReadStatusReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:adad1108af887779b61fedfc47bc127ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Status register.  <a href="#adad1108af887779b61fedfc47bc127ee">More...</a><br /></td></tr>
<tr class="separator:adad1108af887779b61fedfc47bc127ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4cc08551630f3fd29023fb567f585e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a3c4cc08551630f3fd29023fb567f585e">RTC_PDD_WriteStatusReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a3c4cc08551630f3fd29023fb567f585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Status register.  <a href="#a3c4cc08551630f3fd29023fb567f585e">More...</a><br /></td></tr>
<tr class="separator:a3c4cc08551630f3fd29023fb567f585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be4929ed1dd854d124994af7f87e70c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a4be4929ed1dd854d124994af7f87e70c">RTC_PDD_EnableCounter</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:a4be4929ed1dd854d124994af7f87e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables seconds counter.  <a href="#a4be4929ed1dd854d124994af7f87e70c">More...</a><br /></td></tr>
<tr class="separator:a4be4929ed1dd854d124994af7f87e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f0574b7bf84752511f55210108861a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a65f0574b7bf84752511f55210108861a">RTC_PDD_GetEnableCounterStatus</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a65f0574b7bf84752511f55210108861a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns zero if the Time counter is disabled else return non-zero value.  <a href="#a65f0574b7bf84752511f55210108861a">More...</a><br /></td></tr>
<tr class="separator:a65f0574b7bf84752511f55210108861a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19e94746c7370a54d893b716c371c7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ae19e94746c7370a54d893b716c371c7e">RTC_PDD_ReadLockReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ae19e94746c7370a54d893b716c371c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Lock register.  <a href="#ae19e94746c7370a54d893b716c371c7e">More...</a><br /></td></tr>
<tr class="separator:ae19e94746c7370a54d893b716c371c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef472e29a6b17d294c59d1c3034b18c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aef472e29a6b17d294c59d1c3034b18c1">RTC_PDD_WriteLockReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:aef472e29a6b17d294c59d1c3034b18c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Lock register.  <a href="#aef472e29a6b17d294c59d1c3034b18c1">More...</a><br /></td></tr>
<tr class="separator:aef472e29a6b17d294c59d1c3034b18c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6255de23295c3295d12faf42f7399e0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a6255de23295c3295d12faf42f7399e0e">RTC_PDD_LockStatusReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a6255de23295c3295d12faf42f7399e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a6255de23295c3295d12faf42f7399e0e">More...</a><br /></td></tr>
<tr class="separator:a6255de23295c3295d12faf42f7399e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e59b86297b061640b66007c4c5b9973"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a9e59b86297b061640b66007c4c5b9973">RTC_PDD_LockControlReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a9e59b86297b061640b66007c4c5b9973"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a9e59b86297b061640b66007c4c5b9973">More...</a><br /></td></tr>
<tr class="separator:a9e59b86297b061640b66007c4c5b9973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3f99a246c2de3cae96ecb1d5fda91f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1c3f99a246c2de3cae96ecb1d5fda91f">RTC_PDD_LockTimeComensationReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1c3f99a246c2de3cae96ecb1d5fda91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a1c3f99a246c2de3cae96ecb1d5fda91f">More...</a><br /></td></tr>
<tr class="separator:a1c3f99a246c2de3cae96ecb1d5fda91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66613996cca071936533d8706857de0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ac66613996cca071936533d8706857de0">RTC_PDD_ReadWriteAccessReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ac66613996cca071936533d8706857de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Write access register.  <a href="#ac66613996cca071936533d8706857de0">More...</a><br /></td></tr>
<tr class="separator:ac66613996cca071936533d8706857de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c42e1509ae82a4489512f9ecaa9676"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a80c42e1509ae82a4489512f9ecaa9676">RTC_PDD_WriteWriteAccessReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a80c42e1509ae82a4489512f9ecaa9676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Write access register.  <a href="#a80c42e1509ae82a4489512f9ecaa9676">More...</a><br /></td></tr>
<tr class="separator:a80c42e1509ae82a4489512f9ecaa9676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79788aec20a515df12bbd8fa897c8c53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a79788aec20a515df12bbd8fa897c8c53">RTC_PDD_DisableInterruptEnableRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a79788aec20a515df12bbd8fa897c8c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a79788aec20a515df12bbd8fa897c8c53">More...</a><br /></td></tr>
<tr class="separator:a79788aec20a515df12bbd8fa897c8c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8567d47f3986d85c0a0fd75de6475e90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8567d47f3986d85c0a0fd75de6475e90">RTC_PDD_DisableLockRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a8567d47f3986d85c0a0fd75de6475e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a8567d47f3986d85c0a0fd75de6475e90">More...</a><br /></td></tr>
<tr class="separator:a8567d47f3986d85c0a0fd75de6475e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9da5c8b44ca15f8561006012f36acd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1f9da5c8b44ca15f8561006012f36acd">RTC_PDD_DisableStatusRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1f9da5c8b44ca15f8561006012f36acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a1f9da5c8b44ca15f8561006012f36acd">More...</a><br /></td></tr>
<tr class="separator:a1f9da5c8b44ca15f8561006012f36acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5ada66b03f5df14f47dd59a5fe638c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0c5ada66b03f5df14f47dd59a5fe638c">RTC_PDD_DisableControlRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a0c5ada66b03f5df14f47dd59a5fe638c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a0c5ada66b03f5df14f47dd59a5fe638c">More...</a><br /></td></tr>
<tr class="separator:a0c5ada66b03f5df14f47dd59a5fe638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0892ba70608c47d68006c04a050cd796"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0892ba70608c47d68006c04a050cd796">RTC_PDD_DisableTimeCompensationRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a0892ba70608c47d68006c04a050cd796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a0892ba70608c47d68006c04a050cd796">More...</a><br /></td></tr>
<tr class="separator:a0892ba70608c47d68006c04a050cd796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cfc0e18002ac1e69fad3d99c1614c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a98cfc0e18002ac1e69fad3d99c1614c1">RTC_PDD_DisableTimeAlarmRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a98cfc0e18002ac1e69fad3d99c1614c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a98cfc0e18002ac1e69fad3d99c1614c1">More...</a><br /></td></tr>
<tr class="separator:a98cfc0e18002ac1e69fad3d99c1614c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539d8b1dbb1406f858fdfdc7ee57b962"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a539d8b1dbb1406f858fdfdc7ee57b962">RTC_PDD_DisableTimePrescalerRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a539d8b1dbb1406f858fdfdc7ee57b962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a539d8b1dbb1406f858fdfdc7ee57b962">More...</a><br /></td></tr>
<tr class="separator:a539d8b1dbb1406f858fdfdc7ee57b962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27fd6674dd8cdfd7240677ce2cfa50a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aa27fd6674dd8cdfd7240677ce2cfa50a">RTC_PDD_DisableTimeSecondsRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aa27fd6674dd8cdfd7240677ce2cfa50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#aa27fd6674dd8cdfd7240677ce2cfa50a">More...</a><br /></td></tr>
<tr class="separator:aa27fd6674dd8cdfd7240677ce2cfa50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d50bcc8586f48ec668816f02b5335ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a3d50bcc8586f48ec668816f02b5335ad">RTC_PDD_ReadReadAccessReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a3d50bcc8586f48ec668816f02b5335ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Read access register.  <a href="#a3d50bcc8586f48ec668816f02b5335ad">More...</a><br /></td></tr>
<tr class="separator:a3d50bcc8586f48ec668816f02b5335ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add82e4e48e503fcf4251a184ab909ddb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#add82e4e48e503fcf4251a184ab909ddb">RTC_PDD_WriteReadAccessReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:add82e4e48e503fcf4251a184ab909ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Read access register.  <a href="#add82e4e48e503fcf4251a184ab909ddb">More...</a><br /></td></tr>
<tr class="separator:add82e4e48e503fcf4251a184ab909ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ba06e57979f0d9936dd7d2300df9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ae45ba06e57979f0d9936dd7d2300df9e">RTC_PDD_DisableInterruptEnableRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ae45ba06e57979f0d9936dd7d2300df9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ae45ba06e57979f0d9936dd7d2300df9e">More...</a><br /></td></tr>
<tr class="separator:ae45ba06e57979f0d9936dd7d2300df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad345b857c1b4b168a1a83f03394deee3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad345b857c1b4b168a1a83f03394deee3">RTC_PDD_DisableLockRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ad345b857c1b4b168a1a83f03394deee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ad345b857c1b4b168a1a83f03394deee3">More...</a><br /></td></tr>
<tr class="separator:ad345b857c1b4b168a1a83f03394deee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b5fd30b5332504b49121391536e392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a11b5fd30b5332504b49121391536e392">RTC_PDD_DisableStatusRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a11b5fd30b5332504b49121391536e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a11b5fd30b5332504b49121391536e392">More...</a><br /></td></tr>
<tr class="separator:a11b5fd30b5332504b49121391536e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03e1f943e002bcc0e1dd4de56494207"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad03e1f943e002bcc0e1dd4de56494207">RTC_PDD_DisableControlRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ad03e1f943e002bcc0e1dd4de56494207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ad03e1f943e002bcc0e1dd4de56494207">More...</a><br /></td></tr>
<tr class="separator:ad03e1f943e002bcc0e1dd4de56494207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb79a3573398d99730e1d35ab08a0f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aadb79a3573398d99730e1d35ab08a0f0">RTC_PDD_DisableTimeCompensationRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aadb79a3573398d99730e1d35ab08a0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#aadb79a3573398d99730e1d35ab08a0f0">More...</a><br /></td></tr>
<tr class="separator:aadb79a3573398d99730e1d35ab08a0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8630252239b6aef824823d4a9bbd9dec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8630252239b6aef824823d4a9bbd9dec">RTC_PDD_DisableTimeAlarmRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a8630252239b6aef824823d4a9bbd9dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a8630252239b6aef824823d4a9bbd9dec">More...</a><br /></td></tr>
<tr class="separator:a8630252239b6aef824823d4a9bbd9dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694ace39432f8d9094170267b9d2dea7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a694ace39432f8d9094170267b9d2dea7">RTC_PDD_DisableTimePrescalerRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a694ace39432f8d9094170267b9d2dea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a694ace39432f8d9094170267b9d2dea7">More...</a><br /></td></tr>
<tr class="separator:a694ace39432f8d9094170267b9d2dea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1506d9aae27f92d67144267b689452a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1506d9aae27f92d67144267b689452a1">RTC_PDD_DisableTimeSecondsRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1506d9aae27f92d67144267b689452a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a1506d9aae27f92d67144267b689452a1">More...</a><br /></td></tr>
<tr class="separator:a1506d9aae27f92d67144267b689452a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e513d2c1fff3dbc1a05b1d0fab9e5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a35e513d2c1fff3dbc1a05b1d0fab9e5d">RTC_PDD_EnableMonotonicOverflowInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a35e513d2c1fff3dbc1a05b1d0fab9e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Monotonic counter overflow interrupt.  <a href="#a35e513d2c1fff3dbc1a05b1d0fab9e5d">More...</a><br /></td></tr>
<tr class="separator:a35e513d2c1fff3dbc1a05b1d0fab9e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c0fd8323d1e5ecba2b41073a87d35d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a14c0fd8323d1e5ecba2b41073a87d35d">RTC_PDD_DisableMonotonicOverflowInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a14c0fd8323d1e5ecba2b41073a87d35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Monotonic counter overflow interrupt.  <a href="#a14c0fd8323d1e5ecba2b41073a87d35d">More...</a><br /></td></tr>
<tr class="separator:a14c0fd8323d1e5ecba2b41073a87d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3bcee818ee0755cd9c4918eca3d992"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0e3bcee818ee0755cd9c4918eca3d992">RTC_PDD_LockMonotonicCounterHighReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a0e3bcee818ee0755cd9c4918eca3d992"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a0e3bcee818ee0755cd9c4918eca3d992">More...</a><br /></td></tr>
<tr class="separator:a0e3bcee818ee0755cd9c4918eca3d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2676a73d79f3fad22f4d7550b1eed1ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2676a73d79f3fad22f4d7550b1eed1ec">RTC_PDD_LockMonotonicCounterLowReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2676a73d79f3fad22f4d7550b1eed1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a2676a73d79f3fad22f4d7550b1eed1ec">More...</a><br /></td></tr>
<tr class="separator:a2676a73d79f3fad22f4d7550b1eed1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a147396e76f79b3c97e1b83bb73357"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a80a147396e76f79b3c97e1b83bb73357">RTC_PDD_LockMonotonicEnableReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a80a147396e76f79b3c97e1b83bb73357"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a80a147396e76f79b3c97e1b83bb73357">More...</a><br /></td></tr>
<tr class="separator:a80a147396e76f79b3c97e1b83bb73357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d02dfe2d1ac5b457aa9f9c21e1b8f15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a4d02dfe2d1ac5b457aa9f9c21e1b8f15">RTC_PDD_LockTamperTimeSecondsReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a4d02dfe2d1ac5b457aa9f9c21e1b8f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a4d02dfe2d1ac5b457aa9f9c21e1b8f15">More...</a><br /></td></tr>
<tr class="separator:a4d02dfe2d1ac5b457aa9f9c21e1b8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e90a265e9ca0efb22a1d63104fea96a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a7e90a265e9ca0efb22a1d63104fea96a">RTC_PDD_ReadTamperTimeSecondsReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a7e90a265e9ca0efb22a1d63104fea96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Tamper time seconds register.  <a href="#a7e90a265e9ca0efb22a1d63104fea96a">More...</a><br /></td></tr>
<tr class="separator:a7e90a265e9ca0efb22a1d63104fea96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9a3d79b01ddc51b7056c05145fb094"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a5d9a3d79b01ddc51b7056c05145fb094">RTC_PDD_GetTamperTime</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a5d9a3d79b01ddc51b7056c05145fb094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Tamper time in seconds.  <a href="#a5d9a3d79b01ddc51b7056c05145fb094">More...</a><br /></td></tr>
<tr class="separator:a5d9a3d79b01ddc51b7056c05145fb094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c89348f4c6a03bbbdac79c5806c9447"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a0c89348f4c6a03bbbdac79c5806c9447">RTC_PDD_ReadMonotonicEnableReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a0c89348f4c6a03bbbdac79c5806c9447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Monotonic enable register.  <a href="#a0c89348f4c6a03bbbdac79c5806c9447">More...</a><br /></td></tr>
<tr class="separator:a0c89348f4c6a03bbbdac79c5806c9447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2bc03b643c34aa2d838f4940efced1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a9b2bc03b643c34aa2d838f4940efced1">RTC_PDD_WriteMonotonicEnableReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a9b2bc03b643c34aa2d838f4940efced1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Monotonic enable register.  <a href="#a9b2bc03b643c34aa2d838f4940efced1">More...</a><br /></td></tr>
<tr class="separator:a9b2bc03b643c34aa2d838f4940efced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc32248ac0c4f84aed919a6fd1027e75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#acc32248ac0c4f84aed919a6fd1027e75">RTC_PDD_EnableMonotonicCounter</a>(PeripheralBase,  <a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>)</td></tr>
<tr class="memdesc:acc32248ac0c4f84aed919a6fd1027e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables Monotonis counter counter.  <a href="#acc32248ac0c4f84aed919a6fd1027e75">More...</a><br /></td></tr>
<tr class="separator:acc32248ac0c4f84aed919a6fd1027e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34632f9df5ff3798a25844b79fced3e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a34632f9df5ff3798a25844b79fced3e9">RTC_PDD_GetMonotonicCounterEnableStatus</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a34632f9df5ff3798a25844b79fced3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns zero if the Monotonic counter is disabled else return non-zero value.  <a href="#a34632f9df5ff3798a25844b79fced3e9">More...</a><br /></td></tr>
<tr class="separator:a34632f9df5ff3798a25844b79fced3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe6c83828ac784abd4d5de65a2408e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a7fe6c83828ac784abd4d5de65a2408e3">RTC_PDD_ReadMonotonicCounterHighReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a7fe6c83828ac784abd4d5de65a2408e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Monotonic counter high register.  <a href="#a7fe6c83828ac784abd4d5de65a2408e3">More...</a><br /></td></tr>
<tr class="separator:a7fe6c83828ac784abd4d5de65a2408e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df7f7b754db931d38279b3c5ffe0bb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2df7f7b754db931d38279b3c5ffe0bb4">RTC_PDD_WriteMonotonicCounterHigReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a2df7f7b754db931d38279b3c5ffe0bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Monotonic counter high register.  <a href="#a2df7f7b754db931d38279b3c5ffe0bb4">More...</a><br /></td></tr>
<tr class="separator:a2df7f7b754db931d38279b3c5ffe0bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fe2d14dc6d7c908ad30e4840279a09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a30fe2d14dc6d7c908ad30e4840279a09">RTC_PDD_ReadMonotonicCounterLowReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a30fe2d14dc6d7c908ad30e4840279a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Monotonic counter low register.  <a href="#a30fe2d14dc6d7c908ad30e4840279a09">More...</a><br /></td></tr>
<tr class="separator:a30fe2d14dc6d7c908ad30e4840279a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054e742b4e5e61613b13a7b671f5d230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a054e742b4e5e61613b13a7b671f5d230">RTC_PDD_WriteMonotonicCounterLowgReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:a054e742b4e5e61613b13a7b671f5d230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Monotonic counter low register.  <a href="#a054e742b4e5e61613b13a7b671f5d230">More...</a><br /></td></tr>
<tr class="separator:a054e742b4e5e61613b13a7b671f5d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6daa1b1a5d82d8c09d7db529e321b54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad6daa1b1a5d82d8c09d7db529e321b54">RTC_PDD_DisableMonotonicCounterHighRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ad6daa1b1a5d82d8c09d7db529e321b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ad6daa1b1a5d82d8c09d7db529e321b54">More...</a><br /></td></tr>
<tr class="separator:ad6daa1b1a5d82d8c09d7db529e321b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8174320e8154bba8377005b5383137f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8174320e8154bba8377005b5383137f1">RTC_PDD_DisableMonotonicCounterLowRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a8174320e8154bba8377005b5383137f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a8174320e8154bba8377005b5383137f1">More...</a><br /></td></tr>
<tr class="separator:a8174320e8154bba8377005b5383137f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65af00c4825db32b03f15274db38089"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad65af00c4825db32b03f15274db38089">RTC_PDD_DisableMonotonicEnableRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ad65af00c4825db32b03f15274db38089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ad65af00c4825db32b03f15274db38089">More...</a><br /></td></tr>
<tr class="separator:ad65af00c4825db32b03f15274db38089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c54a567f209ac84af21af9ffac3b4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a65c54a567f209ac84af21af9ffac3b4c">RTC_PDD_DisableTamperTimeSecondsRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a65c54a567f209ac84af21af9ffac3b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a65c54a567f209ac84af21af9ffac3b4c">More...</a><br /></td></tr>
<tr class="separator:a65c54a567f209ac84af21af9ffac3b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284bb38a0a11e14671588c4097b0486d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a284bb38a0a11e14671588c4097b0486d">RTC_PDD_DisableMonotonicCounterHighRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a284bb38a0a11e14671588c4097b0486d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a284bb38a0a11e14671588c4097b0486d">More...</a><br /></td></tr>
<tr class="separator:a284bb38a0a11e14671588c4097b0486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36be6a8ce903ec3559be645cc8457067"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a36be6a8ce903ec3559be645cc8457067">RTC_PDD_DisableMonotonicCounterLowRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a36be6a8ce903ec3559be645cc8457067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a36be6a8ce903ec3559be645cc8457067">More...</a><br /></td></tr>
<tr class="separator:a36be6a8ce903ec3559be645cc8457067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1158f352d4d461cba3b02e936345fdbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1158f352d4d461cba3b02e936345fdbc">RTC_PDD_DisableMonotonicEnableRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1158f352d4d461cba3b02e936345fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a1158f352d4d461cba3b02e936345fdbc">More...</a><br /></td></tr>
<tr class="separator:a1158f352d4d461cba3b02e936345fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7d7a47f2738b454353093bf0a8975d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aec7d7a47f2738b454353093bf0a8975d">RTC_PDD_DisableTamperTimeSecondsRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aec7d7a47f2738b454353093bf0a8975d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#aec7d7a47f2738b454353093bf0a8975d">More...</a><br /></td></tr>
<tr class="separator:aec7d7a47f2738b454353093bf0a8975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdee0a4509d3f3f3dd7503f6cb03d696"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#abdee0a4509d3f3f3dd7503f6cb03d696">RTC_PDD_LockTamperInterruptReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:abdee0a4509d3f3f3dd7503f6cb03d696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#abdee0a4509d3f3f3dd7503f6cb03d696">More...</a><br /></td></tr>
<tr class="separator:abdee0a4509d3f3f3dd7503f6cb03d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfcc219f1aa8dc02f971ecc6cb51d31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2cfcc219f1aa8dc02f971ecc6cb51d31">RTC_PDD_LockTamperTrimReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2cfcc219f1aa8dc02f971ecc6cb51d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a2cfcc219f1aa8dc02f971ecc6cb51d31">More...</a><br /></td></tr>
<tr class="separator:a2cfcc219f1aa8dc02f971ecc6cb51d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d54aa845cbed8435ed063b294d64a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aa4d54aa845cbed8435ed063b294d64a0">RTC_PDD_LockTamperDetectReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aa4d54aa845cbed8435ed063b294d64a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#aa4d54aa845cbed8435ed063b294d64a0">More...</a><br /></td></tr>
<tr class="separator:aa4d54aa845cbed8435ed063b294d64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2818d87bf2c89150caafded71f7ae557"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2818d87bf2c89150caafded71f7ae557">RTC_PDD_LockTamperEnableReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2818d87bf2c89150caafded71f7ae557"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error.  <a href="#a2818d87bf2c89150caafded71f7ae557">More...</a><br /></td></tr>
<tr class="separator:a2818d87bf2c89150caafded71f7ae557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c0ca495aab94fc9e9bdbc0ed5f6cac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a12c0ca495aab94fc9e9bdbc0ed5f6cac">RTC_PDD_GetRtcTamperInterruptMask</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a12c0ca495aab94fc9e9bdbc0ed5f6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the RTC tamper interrupt register.  <a href="#a12c0ca495aab94fc9e9bdbc0ed5f6cac">More...</a><br /></td></tr>
<tr class="separator:a12c0ca495aab94fc9e9bdbc0ed5f6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207da0b8cb1b702423cfc7bfedbafc08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a207da0b8cb1b702423cfc7bfedbafc08">RTC_PDD_SetRtcTamperInterruptMask</a>(PeripheralBase,  Mask)</td></tr>
<tr class="memdesc:a207da0b8cb1b702423cfc7bfedbafc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables RTC tamper interrupts defined by the Mask parameter.  <a href="#a207da0b8cb1b702423cfc7bfedbafc08">More...</a><br /></td></tr>
<tr class="separator:a207da0b8cb1b702423cfc7bfedbafc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db18f95e0cb1e1460d9863958adc777"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a5db18f95e0cb1e1460d9863958adc777">RTC_PDD_EnableTestModeInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a5db18f95e0cb1e1460d9863958adc777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Test mode interrupt.  <a href="#a5db18f95e0cb1e1460d9863958adc777">More...</a><br /></td></tr>
<tr class="separator:a5db18f95e0cb1e1460d9863958adc777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4edb2c6652c7587b7bcd9044f4e3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#af7f4edb2c6652c7587b7bcd9044f4e3b">RTC_PDD_EnableFlashSecurityInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:af7f4edb2c6652c7587b7bcd9044f4e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Flash security interrupt.  <a href="#af7f4edb2c6652c7587b7bcd9044f4e3b">More...</a><br /></td></tr>
<tr class="separator:af7f4edb2c6652c7587b7bcd9044f4e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a014d6b3d4146d786e8e6e21859af7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a5a014d6b3d4146d786e8e6e21859af7a">RTC_PDD_EnableTemperatureTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a5a014d6b3d4146d786e8e6e21859af7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Temperature tamper interrupt.  <a href="#a5a014d6b3d4146d786e8e6e21859af7a">More...</a><br /></td></tr>
<tr class="separator:a5a014d6b3d4146d786e8e6e21859af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59be43120e97a1050e6cc053cc61013"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ab59be43120e97a1050e6cc053cc61013">RTC_PDD_EnableClockTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ab59be43120e97a1050e6cc053cc61013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Clock tamper interrupt.  <a href="#ab59be43120e97a1050e6cc053cc61013">More...</a><br /></td></tr>
<tr class="separator:ab59be43120e97a1050e6cc053cc61013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ae01a02f8531d3369dcf8067a3d9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a8b9ae01a02f8531d3369dcf8067a3d9f">RTC_PDD_EnableVolatgeTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a8b9ae01a02f8531d3369dcf8067a3d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Voltage tamper interrupt.  <a href="#a8b9ae01a02f8531d3369dcf8067a3d9f">More...</a><br /></td></tr>
<tr class="separator:a8b9ae01a02f8531d3369dcf8067a3d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bae7ae5f7466e804e7367d2bdba0953"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a3bae7ae5f7466e804e7367d2bdba0953">RTC_PDD_EnableDryIceTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a3bae7ae5f7466e804e7367d2bdba0953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the DryIce tamper interrupt.  <a href="#a3bae7ae5f7466e804e7367d2bdba0953">More...</a><br /></td></tr>
<tr class="separator:a3bae7ae5f7466e804e7367d2bdba0953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a870b62fdb57dfac8a61b484a93e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2c4a870b62fdb57dfac8a61b484a93e8">RTC_PDD_DisableTestModeInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2c4a870b62fdb57dfac8a61b484a93e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Test mode interrupt.  <a href="#a2c4a870b62fdb57dfac8a61b484a93e8">More...</a><br /></td></tr>
<tr class="separator:a2c4a870b62fdb57dfac8a61b484a93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b5e16c8619bbd5000b78ebf2db11f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a49b5e16c8619bbd5000b78ebf2db11f6">RTC_PDD_DisableFlashSecurityInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a49b5e16c8619bbd5000b78ebf2db11f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Flash security interrupt.  <a href="#a49b5e16c8619bbd5000b78ebf2db11f6">More...</a><br /></td></tr>
<tr class="separator:a49b5e16c8619bbd5000b78ebf2db11f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76787b69116b49507018cb2675655366"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a76787b69116b49507018cb2675655366">RTC_PDD_DisableTemperatureTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a76787b69116b49507018cb2675655366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Temperature tamper interrupt.  <a href="#a76787b69116b49507018cb2675655366">More...</a><br /></td></tr>
<tr class="separator:a76787b69116b49507018cb2675655366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493bc2bfe7fc51d09a10aedef90fbc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1493bc2bfe7fc51d09a10aedef90fbc6">RTC_PDD_DisableClockTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1493bc2bfe7fc51d09a10aedef90fbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Clock tamper interrupt.  <a href="#a1493bc2bfe7fc51d09a10aedef90fbc6">More...</a><br /></td></tr>
<tr class="separator:a1493bc2bfe7fc51d09a10aedef90fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef041e8778c3547cff3ea48311757a86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aef041e8778c3547cff3ea48311757a86">RTC_PDD_DisableVolatgeTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aef041e8778c3547cff3ea48311757a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Voltage tamper interrupt.  <a href="#aef041e8778c3547cff3ea48311757a86">More...</a><br /></td></tr>
<tr class="separator:aef041e8778c3547cff3ea48311757a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66495c7f93965d8b5b0ef69d6198e97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ac66495c7f93965d8b5b0ef69d6198e97">RTC_PDD_DisableDryIceTamperInterrupt</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ac66495c7f93965d8b5b0ef69d6198e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the DryIce tamper interrupt.  <a href="#ac66495c7f93965d8b5b0ef69d6198e97">More...</a><br /></td></tr>
<tr class="separator:ac66495c7f93965d8b5b0ef69d6198e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccf8828ed9c6476de7e73fc9b148734"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#adccf8828ed9c6476de7e73fc9b148734">RTC_PDD_ReadTamperDetectReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:adccf8828ed9c6476de7e73fc9b148734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Tamper detect register.  <a href="#adccf8828ed9c6476de7e73fc9b148734">More...</a><br /></td></tr>
<tr class="separator:adccf8828ed9c6476de7e73fc9b148734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac5e04ba0273608be155218f75a343"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aeaac5e04ba0273608be155218f75a343">RTC_PDD_WriteTamperDetectReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:aeaac5e04ba0273608be155218f75a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Tamper detect register.  <a href="#aeaac5e04ba0273608be155218f75a343">More...</a><br /></td></tr>
<tr class="separator:aeaac5e04ba0273608be155218f75a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95e6be41bc311d05429db8fd281b290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ad95e6be41bc311d05429db8fd281b290">RTC_PDD_DisableTamperInterruptRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ad95e6be41bc311d05429db8fd281b290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#ad95e6be41bc311d05429db8fd281b290">More...</a><br /></td></tr>
<tr class="separator:ad95e6be41bc311d05429db8fd281b290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a03785b7f61e1f957f859e20f9076"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aea3a03785b7f61e1f957f859e20f9076">RTC_PDD_DisableTamperTrimRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:aea3a03785b7f61e1f957f859e20f9076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#aea3a03785b7f61e1f957f859e20f9076">More...</a><br /></td></tr>
<tr class="separator:aea3a03785b7f61e1f957f859e20f9076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982db75db757024580c0d1d34b338b31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a982db75db757024580c0d1d34b338b31">RTC_PDD_DisableTamperDetectRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a982db75db757024580c0d1d34b338b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a982db75db757024580c0d1d34b338b31">More...</a><br /></td></tr>
<tr class="separator:a982db75db757024580c0d1d34b338b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f049a68a37b632ba0094e446317366c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a6f049a68a37b632ba0094e446317366c">RTC_PDD_DisableTamperEnableRegWrite</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a6f049a68a37b632ba0094e446317366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a6f049a68a37b632ba0094e446317366c">More...</a><br /></td></tr>
<tr class="separator:a6f049a68a37b632ba0094e446317366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d852c24e03416dd9d1a46035f8107f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#ab3d852c24e03416dd9d1a46035f8107f">RTC_PDD_ReadTamperTrimReg</a>(PeripheralBase)</td></tr>
<tr class="memdesc:ab3d852c24e03416dd9d1a46035f8107f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the Tamper trim register.  <a href="#ab3d852c24e03416dd9d1a46035f8107f">More...</a><br /></td></tr>
<tr class="separator:ab3d852c24e03416dd9d1a46035f8107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa78b3394ecc51ebc05d31b6b670c05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#aafa78b3394ecc51ebc05d31b6b670c05">RTC_PDD_WriteTamperTrimReg</a>(PeripheralBase,  Value)</td></tr>
<tr class="memdesc:aafa78b3394ecc51ebc05d31b6b670c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes value to the Tamper trim register.  <a href="#aafa78b3394ecc51ebc05d31b6b670c05">More...</a><br /></td></tr>
<tr class="separator:aafa78b3394ecc51ebc05d31b6b670c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8598e0b6c45332bb113c9fdccbd964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#adb8598e0b6c45332bb113c9fdccbd964">RTC_PDD_DisableTamperInterruptRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:adb8598e0b6c45332bb113c9fdccbd964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#adb8598e0b6c45332bb113c9fdccbd964">More...</a><br /></td></tr>
<tr class="separator:adb8598e0b6c45332bb113c9fdccbd964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce699326b57cc048926082304305a5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a1ce699326b57cc048926082304305a5d">RTC_PDD_DisableTamperTrimRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a1ce699326b57cc048926082304305a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a1ce699326b57cc048926082304305a5d">More...</a><br /></td></tr>
<tr class="separator:a1ce699326b57cc048926082304305a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3234ac48984d0f3136eac89ec6c8e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2c3234ac48984d0f3136eac89ec6c8e5">RTC_PDD_DisableTamperDetectRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2c3234ac48984d0f3136eac89ec6c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a2c3234ac48984d0f3136eac89ec6c8e5">More...</a><br /></td></tr>
<tr class="separator:a2c3234ac48984d0f3136eac89ec6c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbdd2b1702701956b01496b1f79b885"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_t_c___p_d_d_8h.html#a2dbdd2b1702701956b01496b1f79b885">RTC_PDD_DisableTamperEnableRegRead</a>(PeripheralBase)</td></tr>
<tr class="memdesc:a2dbdd2b1702701956b01496b1f79b885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error.  <a href="#a2dbdd2b1702701956b01496b1f79b885">More...</a><br /></td></tr>
<tr class="separator:a2dbdd2b1702701956b01496b1f79b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0e63cd9f06582f50609a7450f7072e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e63cd9f06582f50609a7450f7072e21">&#9670;&nbsp;</a></span>RTC_PDD_ASSERTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ASSERTED&#160;&#160;&#160;0x8U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin is asserted </p>

</div>
</div>
<a id="aa611383e95284c75839569bb3bd58195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa611383e95284c75839569bb3bd58195">&#9670;&nbsp;</a></span>RTC_PDD_CTF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_CTF_INT&#160;&#160;&#160;RTC_TDR_CTF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock tamper interrupt mask </p>

</div>
</div>
<a id="a4d131732142356708552e11c4beb77cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d131732142356708552e11c4beb77cc">&#9670;&nbsp;</a></span>RTC_PDD_DisableAlarmInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableAlarmInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#gad1bcc4df9a637ec5ab4b611391986c06">RTC_IER_TAIE_MASK</a>) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_gad1bcc4df9a637ec5ab4b611391986c06"><div class="ttname"><a href="group___r_t_c___register___masks.html#gad1bcc4df9a637ec5ab4b611391986c06">RTC_IER_TAIE_MASK</a></div><div class="ttdeci">#define RTC_IER_TAIE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4944</div></div>
</div><!-- fragment -->
<p>Disables the Alarm interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a4d131732142356708552e11c4beb77cc">RTC_PDD_DisableAlarmInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1493bc2bfe7fc51d09a10aedef90fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493bc2bfe7fc51d09a10aedef90fbc6">&#9670;&nbsp;</a></span>RTC_PDD_DisableClockTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableClockTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_CTIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Clock tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1493bc2bfe7fc51d09a10aedef90fbc6">RTC_PDD_DisableClockTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad03e1f943e002bcc0e1dd4de56494207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03e1f943e002bcc0e1dd4de56494207">&#9670;&nbsp;</a></span>RTC_PDD_DisableControlRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableControlRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_CRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad03e1f943e002bcc0e1dd4de56494207">RTC_PDD_DisableControlRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0c5ada66b03f5df14f47dd59a5fe638c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5ada66b03f5df14f47dd59a5fe638c">&#9670;&nbsp;</a></span>RTC_PDD_DisableControlRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableControlRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_CRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a0c5ada66b03f5df14f47dd59a5fe638c">RTC_PDD_DisableControlRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac66495c7f93965d8b5b0ef69d6198e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66495c7f93965d8b5b0ef69d6198e97">&#9670;&nbsp;</a></span>RTC_PDD_DisableDryIceTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableDryIceTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_DTIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the DryIce tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ac66495c7f93965d8b5b0ef69d6198e97">RTC_PDD_DisableDryIceTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a49b5e16c8619bbd5000b78ebf2db11f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b5e16c8619bbd5000b78ebf2db11f6">&#9670;&nbsp;</a></span>RTC_PDD_DisableFlashSecurityInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableFlashSecurityInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_FSIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Flash security interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a49b5e16c8619bbd5000b78ebf2db11f6">RTC_PDD_DisableFlashSecurityInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae45ba06e57979f0d9936dd7d2300df9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45ba06e57979f0d9936dd7d2300df9e">&#9670;&nbsp;</a></span>RTC_PDD_DisableInterruptEnableRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableInterruptEnableRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_IERR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ae45ba06e57979f0d9936dd7d2300df9e">RTC_PDD_DisableInterruptEnableRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a79788aec20a515df12bbd8fa897c8c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79788aec20a515df12bbd8fa897c8c53">&#9670;&nbsp;</a></span>RTC_PDD_DisableInterruptEnableRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableInterruptEnableRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_IERW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a79788aec20a515df12bbd8fa897c8c53">RTC_PDD_DisableInterruptEnableRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad345b857c1b4b168a1a83f03394deee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad345b857c1b4b168a1a83f03394deee3">&#9670;&nbsp;</a></span>RTC_PDD_DisableLockRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableLockRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_LRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad345b857c1b4b168a1a83f03394deee3">RTC_PDD_DisableLockRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8567d47f3986d85c0a0fd75de6475e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8567d47f3986d85c0a0fd75de6475e90">&#9670;&nbsp;</a></span>RTC_PDD_DisableLockRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableLockRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_LRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a8567d47f3986d85c0a0fd75de6475e90">RTC_PDD_DisableLockRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a284bb38a0a11e14671588c4097b0486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284bb38a0a11e14671588c4097b0486d">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicCounterHighRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicCounterHighRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_MCHR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a284bb38a0a11e14671588c4097b0486d">RTC_PDD_DisableMonotonicCounterHighRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad6daa1b1a5d82d8c09d7db529e321b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6daa1b1a5d82d8c09d7db529e321b54">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicCounterHighRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicCounterHighRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_MCHW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad6daa1b1a5d82d8c09d7db529e321b54">RTC_PDD_DisableMonotonicCounterHighRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a36be6a8ce903ec3559be645cc8457067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36be6a8ce903ec3559be645cc8457067">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicCounterLowRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicCounterLowRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_MCLR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a36be6a8ce903ec3559be645cc8457067">RTC_PDD_DisableMonotonicCounterLowRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8174320e8154bba8377005b5383137f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8174320e8154bba8377005b5383137f1">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicCounterLowRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicCounterLowRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_MCLW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a8174320e8154bba8377005b5383137f1">RTC_PDD_DisableMonotonicCounterLowRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1158f352d4d461cba3b02e936345fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1158f352d4d461cba3b02e936345fdbc">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicEnableRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicEnableRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_MERR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1158f352d4d461cba3b02e936345fdbc">RTC_PDD_DisableMonotonicEnableRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad65af00c4825db32b03f15274db38089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65af00c4825db32b03f15274db38089">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicEnableRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicEnableRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_MERW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad65af00c4825db32b03f15274db38089">RTC_PDD_DisableMonotonicEnableRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a14c0fd8323d1e5ecba2b41073a87d35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c0fd8323d1e5ecba2b41073a87d35d">&#9670;&nbsp;</a></span>RTC_PDD_DisableMonotonicOverflowInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableMonotonicOverflowInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_IER_MOIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Monotonic counter overflow interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a14c0fd8323d1e5ecba2b41073a87d35d">RTC_PDD_DisableMonotonicOverflowInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a17829684ce4f1f59e655ae847caf9927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17829684ce4f1f59e655ae847caf9927">&#9670;&nbsp;</a></span>RTC_PDD_DisableSecondsInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableSecondsInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga63c8ae5db82845d5bb13907cd0e70cd7">RTC_IER_TSIE_MASK</a>) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga63c8ae5db82845d5bb13907cd0e70cd7"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga63c8ae5db82845d5bb13907cd0e70cd7">RTC_IER_TSIE_MASK</a></div><div class="ttdeci">#define RTC_IER_TSIE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4946</div></div>
</div><!-- fragment -->
<p>Disables the Seconds interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a17829684ce4f1f59e655ae847caf9927">RTC_PDD_DisableSecondsInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a11b5fd30b5332504b49121391536e392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b5fd30b5332504b49121391536e392">&#9670;&nbsp;</a></span>RTC_PDD_DisableStatusRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableStatusRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_SRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a11b5fd30b5332504b49121391536e392">RTC_PDD_DisableStatusRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1f9da5c8b44ca15f8561006012f36acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9da5c8b44ca15f8561006012f36acd">&#9670;&nbsp;</a></span>RTC_PDD_DisableStatusRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableStatusRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_SRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1f9da5c8b44ca15f8561006012f36acd">RTC_PDD_DisableStatusRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2c3234ac48984d0f3136eac89ec6c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3234ac48984d0f3136eac89ec6c8e5">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperDetectRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperDetectRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_RAR_TDRR_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2c3234ac48984d0f3136eac89ec6c8e5">RTC_PDD_DisableTamperDetectRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a982db75db757024580c0d1d34b338b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982db75db757024580c0d1d34b338b31">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperDetectRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperDetectRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_WAR_TDRW_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a982db75db757024580c0d1d34b338b31">RTC_PDD_DisableTamperDetectRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2dbdd2b1702701956b01496b1f79b885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbdd2b1702701956b01496b1f79b885">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperEnableRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperEnableRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_RAR_TERR_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2dbdd2b1702701956b01496b1f79b885">RTC_PDD_DisableTamperEnableRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6f049a68a37b632ba0094e446317366c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f049a68a37b632ba0094e446317366c">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperEnableRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperEnableRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_WAR_TERW_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a6f049a68a37b632ba0094e446317366c">RTC_PDD_DisableTamperEnableRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb8598e0b6c45332bb113c9fdccbd964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8598e0b6c45332bb113c9fdccbd964">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperInterruptRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperInterruptRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_RAR_TIRR_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#adb8598e0b6c45332bb113c9fdccbd964">RTC_PDD_DisableTamperInterruptRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad95e6be41bc311d05429db8fd281b290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95e6be41bc311d05429db8fd281b290">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperInterruptRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperInterruptRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_WAR_TIRW_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad95e6be41bc311d05429db8fd281b290">RTC_PDD_DisableTamperInterruptRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aec7d7a47f2738b454353093bf0a8975d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7d7a47f2738b454353093bf0a8975d">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperTimeSecondsRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperTimeSecondsRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_TTSR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aec7d7a47f2738b454353093bf0a8975d">RTC_PDD_DisableTamperTimeSecondsRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a65c54a567f209ac84af21af9ffac3b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c54a567f209ac84af21af9ffac3b4c">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperTimeSecondsRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperTimeSecondsRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_TTSW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a65c54a567f209ac84af21af9ffac3b4c">RTC_PDD_DisableTamperTimeSecondsRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1ce699326b57cc048926082304305a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce699326b57cc048926082304305a5d">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperTrimRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperTrimRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_RAR_TTRR_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1ce699326b57cc048926082304305a5d">RTC_PDD_DisableTamperTrimRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aea3a03785b7f61e1f957f859e20f9076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3a03785b7f61e1f957f859e20f9076">&#9670;&nbsp;</a></span>RTC_PDD_DisableTamperTrimRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTamperTrimRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_WAR_TTRW_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aea3a03785b7f61e1f957f859e20f9076">RTC_PDD_DisableTamperTrimRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a76787b69116b49507018cb2675655366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76787b69116b49507018cb2675655366">&#9670;&nbsp;</a></span>RTC_PDD_DisableTemperatureTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTemperatureTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_TTIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Temperature tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a76787b69116b49507018cb2675655366">RTC_PDD_DisableTemperatureTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2c4a870b62fdb57dfac8a61b484a93e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4a870b62fdb57dfac8a61b484a93e8">&#9670;&nbsp;</a></span>RTC_PDD_DisableTestModeInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTestModeInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_TMIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Test mode interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2c4a870b62fdb57dfac8a61b484a93e8">RTC_PDD_DisableTestModeInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8630252239b6aef824823d4a9bbd9dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630252239b6aef824823d4a9bbd9dec">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeAlarmRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeAlarmRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_TARR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a8630252239b6aef824823d4a9bbd9dec">RTC_PDD_DisableTimeAlarmRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a98cfc0e18002ac1e69fad3d99c1614c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cfc0e18002ac1e69fad3d99c1614c1">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeAlarmRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeAlarmRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_TARW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a98cfc0e18002ac1e69fad3d99c1614c1">RTC_PDD_DisableTimeAlarmRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aadb79a3573398d99730e1d35ab08a0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb79a3573398d99730e1d35ab08a0f0">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeCompensationRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeCompensationRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_TCRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aadb79a3573398d99730e1d35ab08a0f0">RTC_PDD_DisableTimeCompensationRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0892ba70608c47d68006c04a050cd796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0892ba70608c47d68006c04a050cd796">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeCompensationRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeCompensationRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_TCRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a0892ba70608c47d68006c04a050cd796">RTC_PDD_DisableTimeCompensationRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3ba6f9549f12d7134e6628a9a952d4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6f9549f12d7134e6628a9a952d4d5">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeInvalidInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeInvalidInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga4401cd4dce34a638f75403a2a3701e6d">RTC_IER_TIIE_MASK</a>) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga4401cd4dce34a638f75403a2a3701e6d"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga4401cd4dce34a638f75403a2a3701e6d">RTC_IER_TIIE_MASK</a></div><div class="ttdeci">#define RTC_IER_TIIE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4940</div></div>
</div><!-- fragment -->
<p>Disables the Time invalid interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a3ba6f9549f12d7134e6628a9a952d4d5">RTC_PDD_DisableTimeInvalidInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8a17d968ee5bf693d38893e9b23cb08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a17d968ee5bf693d38893e9b23cb08a">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeOverflowInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeOverflowInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga1dfc25308bec00f67925ae796f805d3d">RTC_IER_TOIE_MASK</a>) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga1dfc25308bec00f67925ae796f805d3d"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga1dfc25308bec00f67925ae796f805d3d">RTC_IER_TOIE_MASK</a></div><div class="ttdeci">#define RTC_IER_TOIE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4942</div></div>
</div><!-- fragment -->
<p>Disables the Time overflow interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a8a17d968ee5bf693d38893e9b23cb08a">RTC_PDD_DisableTimeOverflowInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a694ace39432f8d9094170267b9d2dea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694ace39432f8d9094170267b9d2dea7">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimePrescalerRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimePrescalerRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_TPRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a694ace39432f8d9094170267b9d2dea7">RTC_PDD_DisableTimePrescalerRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a539d8b1dbb1406f858fdfdc7ee57b962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539d8b1dbb1406f858fdfdc7ee57b962">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimePrescalerRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimePrescalerRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_TPRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a539d8b1dbb1406f858fdfdc7ee57b962">RTC_PDD_DisableTimePrescalerRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1506d9aae27f92d67144267b689452a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1506d9aae27f92d67144267b689452a1">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeSecondsRegRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeSecondsRegRead</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_RAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_RAR_TSRR_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1506d9aae27f92d67144267b689452a1">RTC_PDD_DisableTimeSecondsRegRead</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa27fd6674dd8cdfd7240677ce2cfa50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27fd6674dd8cdfd7240677ce2cfa50a">&#9670;&nbsp;</a></span>RTC_PDD_DisableTimeSecondsRegWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableTimeSecondsRegWrite</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_WAR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_WAR_TSRW_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the VBAT power supply and does not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aa27fd6674dd8cdfd7240677ce2cfa50a">RTC_PDD_DisableTimeSecondsRegWrite</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aef041e8778c3547cff3ea48311757a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef041e8778c3547cff3ea48311757a86">&#9670;&nbsp;</a></span>RTC_PDD_DisableVolatgeTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DisableVolatgeTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_TIR_VTIE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Disables the Voltage tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aef041e8778c3547cff3ea48311757a86">RTC_PDD_DisableVolatgeTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae25c7f7b278d0a3ced9facc2733e17ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c7f7b278d0a3ced9facc2733e17ca">&#9670;&nbsp;</a></span>RTC_PDD_DTF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_DTF_INT&#160;&#160;&#160;RTC_TDR_DTF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DryIce tamper interrupt mask </p>

</div>
</div>
<a id="a80139a02f86ce73f0bba4eafa5b3dcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80139a02f86ce73f0bba4eafa5b3dcd9">&#9670;&nbsp;</a></span>RTC_PDD_EnableAlarmInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableAlarmInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) |= \</div><div class="line">     RTC_IER_TAIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Alarm interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a80139a02f86ce73f0bba4eafa5b3dcd9">RTC_PDD_EnableAlarmInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab59be43120e97a1050e6cc053cc61013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59be43120e97a1050e6cc053cc61013">&#9670;&nbsp;</a></span>RTC_PDD_EnableClockTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableClockTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_CTIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Clock tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ab59be43120e97a1050e6cc053cc61013">RTC_PDD_EnableClockTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4be4929ed1dd854d124994af7f87e70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be4929ed1dd854d124994af7f87e70c">&#9670;&nbsp;</a></span>RTC_PDD_EnableCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableCounter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    ((<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) == <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>) ? ( \</div><div class="line">      RTC_SR_REG(PeripheralBase) = \</div><div class="line">       0U) : ( \</div><div class="line">      <a class="code" href="group___r_t_c___register___accessor___macros.html#gab87ebfc55a2b4e49ef0c0a52819e27b0">RTC_SR_REG</a>(PeripheralBase) = \</div><div class="line">       0x10U) \</div><div class="line">  )</div><div class="ttc" id="_p_d_d___types_8h_html_ab3f067bf9b5f1a0bee256df53023a37f"><div class="ttname"><a href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a></div><div class="ttdeci">#define PDD_DISABLE</div><div class="ttdef"><b>Definition:</b> PDD_Types.h:37</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_gab87ebfc55a2b4e49ef0c0a52819e27b0"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#gab87ebfc55a2b4e49ef0c0a52819e27b0">RTC_SR_REG</a></div><div class="ttdeci">#define RTC_SR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4857</div></div>
<div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
</div><!-- fragment -->
<p>Enables/disables seconds counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (PDD_DISABLE and PDD_ENABLE defined in <a class="el" href="_p_d_d___types_8h.html">PDD_Types.h</a>)" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_SR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a4be4929ed1dd854d124994af7f87e70c">RTC_PDD_EnableCounter</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3bae7ae5f7466e804e7367d2bdba0953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bae7ae5f7466e804e7367d2bdba0953">&#9670;&nbsp;</a></span>RTC_PDD_EnableDryIceTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableDryIceTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_DTIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the DryIce tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a3bae7ae5f7466e804e7367d2bdba0953">RTC_PDD_EnableDryIceTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af7f4edb2c6652c7587b7bcd9044f4e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f4edb2c6652c7587b7bcd9044f4e3b">&#9670;&nbsp;</a></span>RTC_PDD_EnableFlashSecurityInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableFlashSecurityInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_FSIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Flash security interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#af7f4edb2c6652c7587b7bcd9044f4e3b">RTC_PDD_EnableFlashSecurityInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acc32248ac0c4f84aed919a6fd1027e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc32248ac0c4f84aed919a6fd1027e75">&#9670;&nbsp;</a></span>RTC_PDD_EnableMonotonicCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableMonotonicCounter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    ((<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) == <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>) ? ( \</div><div class="line">      RTC_MER_REG(PeripheralBase) = \</div><div class="line">       0U) : ( \</div><div class="line">      RTC_MER_REG(PeripheralBase) = \</div><div class="line">       0x10U) \</div><div class="line">  )</div><div class="ttc" id="_p_d_d___types_8h_html_ab3f067bf9b5f1a0bee256df53023a37f"><div class="ttname"><a href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a></div><div class="ttdeci">#define PDD_DISABLE</div><div class="ttdef"><b>Definition:</b> PDD_Types.h:37</div></div>
<div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
</div><!-- fragment -->
<p>Enables/disables Monotonis counter counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (PDD_DISABLE and PDD_ENABLE defined in <a class="el" href="_p_d_d___types_8h.html">PDD_Types.h</a>)" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#acc32248ac0c4f84aed919a6fd1027e75">RTC_PDD_EnableMonotonicCounter</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a35e513d2c1fff3dbc1a05b1d0fab9e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e513d2c1fff3dbc1a05b1d0fab9e5d">&#9670;&nbsp;</a></span>RTC_PDD_EnableMonotonicOverflowInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableMonotonicOverflowInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) |= \</div><div class="line">     RTC_IER_MOIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Monotonic counter overflow interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a35e513d2c1fff3dbc1a05b1d0fab9e5d">RTC_PDD_EnableMonotonicOverflowInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a52faa25caeec8beb1b16fa433a5fb25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52faa25caeec8beb1b16fa433a5fb25c">&#9670;&nbsp;</a></span>RTC_PDD_EnableSecondsInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableSecondsInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) |= \</div><div class="line">     RTC_IER_TSIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Seconds interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a52faa25caeec8beb1b16fa433a5fb25c">RTC_PDD_EnableSecondsInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a88f3e11628daff979b256bda935d46e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f3e11628daff979b256bda935d46e7">&#9670;&nbsp;</a></span>RTC_PDD_EnableSupervisorAccess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableSupervisorAccess</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    ((<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) == <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>) ? ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) = \</div><div class="line">       (uint32_t)(( \</div><div class="line">        (uint32_t)(<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) | <a class="code" href="group___r_t_c___register___masks.html#ga762afd0d0e0bbc08b631a10c45222797">RTC_CR_SUP_MASK</a>)) &amp; ( \</div><div class="line">        (uint32_t)(~(uint32_t)0x4000U)))) : ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)((uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga762afd0d0e0bbc08b631a10c45222797">RTC_CR_SUP_MASK</a>) &amp; (uint32_t)(~(uint32_t)0x4000U))) \</div><div class="line">  )</div><div class="ttc" id="_p_d_d___types_8h_html_ab3f067bf9b5f1a0bee256df53023a37f"><div class="ttname"><a href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a></div><div class="ttdeci">#define PDD_DISABLE</div><div class="ttdef"><b>Definition:</b> PDD_Types.h:37</div></div>
<div class="ttc" id="group___r_t_c___register___masks_html_ga762afd0d0e0bbc08b631a10c45222797"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga762afd0d0e0bbc08b631a10c45222797">RTC_CR_SUP_MASK</a></div><div class="ttdeci">#define RTC_CR_SUP_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4905</div></div>
<div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_ga32aa9fd38e099ee1a01f094e5389a794"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a></div><div class="ttdeci">#define RTC_CR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4856</div></div>
</div><!-- fragment -->
<p>Enables/disables supervisor accesss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (PDD_DISABLE and PDD_ENABLE defined in <a class="el" href="_p_d_d___types_8h.html">PDD_Types.h</a>)" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a88f3e11628daff979b256bda935d46e7">RTC_PDD_EnableSupervisorAccess</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5a014d6b3d4146d786e8e6e21859af7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a014d6b3d4146d786e8e6e21859af7a">&#9670;&nbsp;</a></span>RTC_PDD_EnableTemperatureTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableTemperatureTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_TTIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Temperature tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a5a014d6b3d4146d786e8e6e21859af7a">RTC_PDD_EnableTemperatureTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5db18f95e0cb1e1460d9863958adc777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db18f95e0cb1e1460d9863958adc777">&#9670;&nbsp;</a></span>RTC_PDD_EnableTestModeInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableTestModeInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_TMIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Test mode interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a5db18f95e0cb1e1460d9863958adc777">RTC_PDD_EnableTestModeInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2619e9f0c03f0a59e040a436b1381eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2619e9f0c03f0a59e040a436b1381eac">&#9670;&nbsp;</a></span>RTC_PDD_EnableTimeInvalidInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableTimeInvalidInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) |= \</div><div class="line">     RTC_IER_TIIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Time invalid interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2619e9f0c03f0a59e040a436b1381eac">RTC_PDD_EnableTimeInvalidInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac2f20eea4f7c38e1ca3a38515a2df3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f20eea4f7c38e1ca3a38515a2df3af">&#9670;&nbsp;</a></span>RTC_PDD_EnableTimeOverflowInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableTimeOverflowInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) |= \</div><div class="line">     RTC_IER_TOIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Time overflow interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ac2f20eea4f7c38e1ca3a38515a2df3af">RTC_PDD_EnableTimeOverflowInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a73a34d2e72d1a661b4bbccd5fe4be892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a34d2e72d1a661b4bbccd5fe4be892">&#9670;&nbsp;</a></span>RTC_PDD_EnableUpdateMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableUpdateMode</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    ((<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) == <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>) ? ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) = \</div><div class="line">       (uint32_t)(( \</div><div class="line">        (uint32_t)(<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) | <a class="code" href="group___r_t_c___register___masks.html#gae071fafa245264dd485258198b7fcf8a">RTC_CR_UM_MASK</a>)) &amp; ( \</div><div class="line">        (uint32_t)(~(uint32_t)0x4000U)))) : ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)((uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#gae071fafa245264dd485258198b7fcf8a">RTC_CR_UM_MASK</a>) &amp; (uint32_t)(~(uint32_t)0x4000U))) \</div><div class="line">  )</div><div class="ttc" id="_p_d_d___types_8h_html_ab3f067bf9b5f1a0bee256df53023a37f"><div class="ttname"><a href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a></div><div class="ttdeci">#define PDD_DISABLE</div><div class="ttdef"><b>Definition:</b> PDD_Types.h:37</div></div>
<div class="ttc" id="group___r_t_c___register___masks_html_gae071fafa245264dd485258198b7fcf8a"><div class="ttname"><a href="group___r_t_c___register___masks.html#gae071fafa245264dd485258198b7fcf8a">RTC_CR_UM_MASK</a></div><div class="ttdeci">#define RTC_CR_UM_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4907</div></div>
<div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_ga32aa9fd38e099ee1a01f094e5389a794"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a></div><div class="ttdeci">#define RTC_CR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4856</div></div>
</div><!-- fragment -->
<p>Enables/disables update mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (PDD_DISABLE and PDD_ENABLE defined in <a class="el" href="_p_d_d___types_8h.html">PDD_Types.h</a>)" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a73a34d2e72d1a661b4bbccd5fe4be892">RTC_PDD_EnableUpdateMode</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8b9ae01a02f8531d3369dcf8067a3d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ae01a02f8531d3369dcf8067a3d9f">&#9670;&nbsp;</a></span>RTC_PDD_EnableVolatgeTamperInterrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableVolatgeTamperInterrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) |= \</div><div class="line">     RTC_TIR_VTIE_MASK \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables the Voltage tamper interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a8b9ae01a02f8531d3369dcf8067a3d9f">RTC_PDD_EnableVolatgeTamperInterrupt</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a116eeaa0c821be7394233415fa9dfcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116eeaa0c821be7394233415fa9dfcdd">&#9670;&nbsp;</a></span>RTC_PDD_EnableWakeupPin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_EnableWakeupPin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    ((<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) == <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>) ? ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) = \</div><div class="line">       (uint32_t)(( \</div><div class="line">        (uint32_t)(<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) | <a class="code" href="group___r_t_c___register___masks.html#gade2b0c86902f83d7674c10e3a7923f80">RTC_CR_WPE_MASK</a>)) &amp; ( \</div><div class="line">        (uint32_t)(~(uint32_t)0x4000U)))) : ( \</div><div class="line">      RTC_CR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)((uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#gade2b0c86902f83d7674c10e3a7923f80">RTC_CR_WPE_MASK</a>) &amp; (uint32_t)(~(uint32_t)0x4000U))) \</div><div class="line">  )</div><div class="ttc" id="_p_d_d___types_8h_html_ab3f067bf9b5f1a0bee256df53023a37f"><div class="ttname"><a href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a></div><div class="ttdeci">#define PDD_DISABLE</div><div class="ttdef"><b>Definition:</b> PDD_Types.h:37</div></div>
<div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_ga32aa9fd38e099ee1a01f094e5389a794"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a></div><div class="ttdeci">#define RTC_CR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4856</div></div>
<div class="ttc" id="group___r_t_c___register___masks_html_gade2b0c86902f83d7674c10e3a7923f80"><div class="ttname"><a href="group___r_t_c___register___masks.html#gade2b0c86902f83d7674c10e3a7923f80">RTC_CR_WPE_MASK</a></div><div class="ttdeci">#define RTC_CR_WPE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4903</div></div>
</div><!-- fragment -->
<p>Enables/disables wakeup pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (PDD_DISABLE and PDD_ENABLE defined in <a class="el" href="_p_d_d___types_8h.html">PDD_Types.h</a>)" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a116eeaa0c821be7394233415fa9dfcdd">RTC_PDD_EnableWakeupPin</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_p_d_d___types_8h.html#ab3f067bf9b5f1a0bee256df53023a37f">PDD_DISABLE</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4414955b1ed3d7c4fa6bba0d0db31286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4414955b1ed3d7c4fa6bba0d0db31286">&#9670;&nbsp;</a></span>RTC_PDD_ForceSwReset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ForceSwReset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    (<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) = \</div><div class="line">     (uint32_t)(( \</div><div class="line">      (uint32_t)(<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) | <a class="code" href="group___r_t_c___register___masks.html#ga114a670a6ac2782bd777ea33e4395059">RTC_CR_SWR_MASK</a>)) &amp; ( \</div><div class="line">      (uint32_t)(~(uint32_t)0x4000U)))), \</div><div class="line">    (<a class="code" href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a>(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)((uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga114a670a6ac2782bd777ea33e4395059">RTC_CR_SWR_MASK</a>) &amp; (uint32_t)(~(uint32_t)0x4000U))) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga114a670a6ac2782bd777ea33e4395059"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga114a670a6ac2782bd777ea33e4395059">RTC_CR_SWR_MASK</a></div><div class="ttdeci">#define RTC_CR_SWR_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4901</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_ga32aa9fd38e099ee1a01f094e5389a794"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#ga32aa9fd38e099ee1a01f094e5389a794">RTC_CR_REG</a></div><div class="ttdeci">#define RTC_CR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4856</div></div>
</div><!-- fragment -->
<p>Forces the equivalent of a VBAT POR to the rest of the RTC module, except the access control registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a4414955b1ed3d7c4fa6bba0d0db31286">RTC_PDD_ForceSwReset</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8f5945ae44076fa558f026d928bd71cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5945ae44076fa558f026d928bd71cf">&#9670;&nbsp;</a></span>RTC_PDD_FSF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_FSF_INT&#160;&#160;&#160;RTC_TDR_FSF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash security tamper interrupt mask </p>

</div>
</div>
<a id="a65f0574b7bf84752511f55210108861a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f0574b7bf84752511f55210108861a">&#9670;&nbsp;</a></span>RTC_PDD_GetEnableCounterStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_GetEnableCounterStatus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    (uint32_t)(<a class="code" href="group___r_t_c___register___accessor___macros.html#gab87ebfc55a2b4e49ef0c0a52819e27b0">RTC_SR_REG</a>(PeripheralBase) &amp; <a class="code" href="group___r_t_c___register___masks.html#gabcb29faa7aa3cee888e06e6b08236907">RTC_SR_TCE_MASK</a>) \</div><div class="line">  )</div><div class="ttc" id="group___r_t_c___register___masks_html_gabcb29faa7aa3cee888e06e6b08236907"><div class="ttname"><a href="group___r_t_c___register___masks.html#gabcb29faa7aa3cee888e06e6b08236907">RTC_SR_TCE_MASK</a></div><div class="ttdeci">#define RTC_SR_TCE_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4928</div></div>
<div class="ttc" id="group___r_t_c___register___accessor___macros_html_gab87ebfc55a2b4e49ef0c0a52819e27b0"><div class="ttname"><a href="group___r_t_c___register___accessor___macros.html#gab87ebfc55a2b4e49ef0c0a52819e27b0">RTC_SR_REG</a></div><div class="ttdeci">#define RTC_SR_REG(base)</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4857</div></div>
</div><!-- fragment -->
<p>Returns zero if the Time counter is disabled else return non-zero value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_SR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a65f0574b7bf84752511f55210108861a">RTC_PDD_GetEnableCounterStatus</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a34632f9df5ff3798a25844b79fced3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34632f9df5ff3798a25844b79fced3e9">&#9670;&nbsp;</a></span>RTC_PDD_GetMonotonicCounterEnableStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_GetMonotonicCounterEnableStatus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    (uint32_t)(RTC_MER_REG(PeripheralBase) &amp; RTC_MER_MCE_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns zero if the Monotonic counter is disabled else return non-zero value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a34632f9df5ff3798a25844b79fced3e9">RTC_PDD_GetMonotonicCounterEnableStatus</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acc0efeea9283ff1486c8992190b8d772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0efeea9283ff1486c8992190b8d772">&#9670;&nbsp;</a></span>RTC_PDD_GetRtcInterruptMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_GetRtcInterruptMask</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the RTC interrupt enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#acc0efeea9283ff1486c8992190b8d772">RTC_PDD_GetRtcInterruptMask</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a12c0ca495aab94fc9e9bdbc0ed5f6cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c0ca495aab94fc9e9bdbc0ed5f6cac">&#9670;&nbsp;</a></span>RTC_PDD_GetRtcTamperInterruptMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_GetRtcTamperInterruptMask</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the RTC tamper interrupt register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a12c0ca495aab94fc9e9bdbc0ed5f6cac">RTC_PDD_GetRtcTamperInterruptMask</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5d9a3d79b01ddc51b7056c05145fb094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9a3d79b01ddc51b7056c05145fb094">&#9670;&nbsp;</a></span>RTC_PDD_GetTamperTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_GetTamperTime</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TTSR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Tamper time in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TTSR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a5d9a3d79b01ddc51b7056c05145fb094">RTC_PDD_GetTamperTime</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9e59b86297b061640b66007c4c5b9973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e59b86297b061640b66007c4c5b9973">&#9670;&nbsp;</a></span>RTC_PDD_LockControlReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga79d7286374cccca93261d4ced777c2e7">RTC_LR_CRL_MASK</a>) \</div><div class="line">    )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga79d7286374cccca93261d4ced777c2e7"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga79d7286374cccca93261d4ced777c2e7">RTC_LR_CRL_MASK</a></div><div class="ttdeci">#define RTC_LR_CRL_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4933</div></div>
</div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a9e59b86297b061640b66007c4c5b9973">RTC_PDD_LockControlReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0e3bcee818ee0755cd9c4918eca3d992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3bcee818ee0755cd9c4918eca3d992">&#9670;&nbsp;</a></span>RTC_PDD_LockMonotonicCounterHighReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockMonotonicCounterHighReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_LR_MCHL_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a0e3bcee818ee0755cd9c4918eca3d992">RTC_PDD_LockMonotonicCounterHighReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2676a73d79f3fad22f4d7550b1eed1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2676a73d79f3fad22f4d7550b1eed1ec">&#9670;&nbsp;</a></span>RTC_PDD_LockMonotonicCounterLowReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockMonotonicCounterLowReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_LR_MCLL_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2676a73d79f3fad22f4d7550b1eed1ec">RTC_PDD_LockMonotonicCounterLowReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a80a147396e76f79b3c97e1b83bb73357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a147396e76f79b3c97e1b83bb73357">&#9670;&nbsp;</a></span>RTC_PDD_LockMonotonicEnableReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockMonotonicEnableReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_LR_MEL_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a80a147396e76f79b3c97e1b83bb73357">RTC_PDD_LockMonotonicEnableReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6255de23295c3295d12faf42f7399e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6255de23295c3295d12faf42f7399e0e">&#9670;&nbsp;</a></span>RTC_PDD_LockStatusReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga0681f481e213872418c16d5e012e5603">RTC_LR_SRL_MASK</a>) \</div><div class="line">    )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga0681f481e213872418c16d5e012e5603"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga0681f481e213872418c16d5e012e5603">RTC_LR_SRL_MASK</a></div><div class="ttdeci">#define RTC_LR_SRL_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4935</div></div>
</div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a6255de23295c3295d12faf42f7399e0e">RTC_PDD_LockStatusReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa4d54aa845cbed8435ed063b294d64a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d54aa845cbed8435ed063b294d64a0">&#9670;&nbsp;</a></span>RTC_PDD_LockTamperDetectReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTamperDetectReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_LR_TDL_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aa4d54aa845cbed8435ed063b294d64a0">RTC_PDD_LockTamperDetectReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2818d87bf2c89150caafded71f7ae557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2818d87bf2c89150caafded71f7ae557">&#9670;&nbsp;</a></span>RTC_PDD_LockTamperEnableReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTamperEnableReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_LR_TEL_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2818d87bf2c89150caafded71f7ae557">RTC_PDD_LockTamperEnableReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abdee0a4509d3f3f3dd7503f6cb03d696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdee0a4509d3f3f3dd7503f6cb03d696">&#9670;&nbsp;</a></span>RTC_PDD_LockTamperInterruptReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTamperInterruptReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_LR_TIL_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#abdee0a4509d3f3f3dd7503f6cb03d696">RTC_PDD_LockTamperInterruptReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4d02dfe2d1ac5b457aa9f9c21e1b8f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d02dfe2d1ac5b457aa9f9c21e1b8f15">&#9670;&nbsp;</a></span>RTC_PDD_LockTamperTimeSecondsReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTamperTimeSecondsReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)RTC_LR_TTSL_MASK) \</div><div class="line">    )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a4d02dfe2d1ac5b457aa9f9c21e1b8f15">RTC_PDD_LockTamperTimeSecondsReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2cfcc219f1aa8dc02f971ecc6cb51d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfcc219f1aa8dc02f971ecc6cb51d31">&#9670;&nbsp;</a></span>RTC_PDD_LockTamperTrimReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTamperTrimReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">     (uint32_t)(~(uint32_t)RTC_LR_TTL_MASK) \</div><div class="line">  )</div></div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2cfcc219f1aa8dc02f971ecc6cb51d31">RTC_PDD_LockTamperTrimReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1c3f99a246c2de3cae96ecb1d5fda91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3f99a246c2de3cae96ecb1d5fda91f">&#9670;&nbsp;</a></span>RTC_PDD_LockTimeComensationReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_LockTimeComensationReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_LR_REG(PeripheralBase) &amp;= \</div><div class="line">       (uint32_t)(~(uint32_t)<a class="code" href="group___r_t_c___register___masks.html#ga89f5d0ce94e7eb13bd961774fd440c0b">RTC_LR_TCL_MASK</a>) \</div><div class="line">    )</div><div class="ttc" id="group___r_t_c___register___masks_html_ga89f5d0ce94e7eb13bd961774fd440c0b"><div class="ttname"><a href="group___r_t_c___register___masks.html#ga89f5d0ce94e7eb13bd961774fd440c0b">RTC_LR_TCL_MASK</a></div><div class="ttdeci">#define RTC_LR_TCL_MASK</div><div class="ttdef"><b>Definition:</b> MKL25Z4.h:4931</div></div>
</div><!-- fragment -->
<p>The lock register is used to block write accesses to certain registers until the next VBAT_POR or software reset.Write accesses to a locked register are ignored and do not generate a bus error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a1c3f99a246c2de3cae96ecb1d5fda91f">RTC_PDD_LockTimeComensationReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab384f783d6acffcf3ca2fbd99bd01430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab384f783d6acffcf3ca2fbd99bd01430">&#9670;&nbsp;</a></span>RTC_PDD_NOT_ASSERTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_NOT_ASSERTED&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin is not asserted </p>

</div>
</div>
<a id="af08ea06ba509408063e58c9034c1da9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08ea06ba509408063e58c9034c1da9d">&#9670;&nbsp;</a></span>RTC_PDD_ReadControlReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_CR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#af08ea06ba509408063e58c9034c1da9d">RTC_PDD_ReadControlReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae19e94746c7370a54d893b716c371c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19e94746c7370a54d893b716c371c7e">&#9670;&nbsp;</a></span>RTC_PDD_ReadLockReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadLockReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Lock register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#ae19e94746c7370a54d893b716c371c7e">RTC_PDD_ReadLockReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7fe6c83828ac784abd4d5de65a2408e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe6c83828ac784abd4d5de65a2408e3">&#9670;&nbsp;</a></span>RTC_PDD_ReadMonotonicCounterHighReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadMonotonicCounterHighReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MCHR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Monotonic counter high register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MCHR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a7fe6c83828ac784abd4d5de65a2408e3">RTC_PDD_ReadMonotonicCounterHighReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30fe2d14dc6d7c908ad30e4840279a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fe2d14dc6d7c908ad30e4840279a09">&#9670;&nbsp;</a></span>RTC_PDD_ReadMonotonicCounterLowReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadMonotonicCounterLowReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MCLR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Monotonic counter low register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MCLR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a30fe2d14dc6d7c908ad30e4840279a09">RTC_PDD_ReadMonotonicCounterLowReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0c89348f4c6a03bbbdac79c5806c9447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c89348f4c6a03bbbdac79c5806c9447">&#9670;&nbsp;</a></span>RTC_PDD_ReadMonotonicEnableReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadMonotonicEnableReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MER_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Monotonic enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a0c89348f4c6a03bbbdac79c5806c9447">RTC_PDD_ReadMonotonicEnableReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3d50bcc8586f48ec668816f02b5335ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d50bcc8586f48ec668816f02b5335ad">&#9670;&nbsp;</a></span>RTC_PDD_ReadReadAccessReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadReadAccessReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Read access register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a3d50bcc8586f48ec668816f02b5335ad">RTC_PDD_ReadReadAccessReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adad1108af887779b61fedfc47bc127ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad1108af887779b61fedfc47bc127ee">&#9670;&nbsp;</a></span>RTC_PDD_ReadStatusReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_SR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Status register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Use constants from group "Interrupt masks" for processing return value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_SR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#adad1108af887779b61fedfc47bc127ee">RTC_PDD_ReadStatusReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adccf8828ed9c6476de7e73fc9b148734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccf8828ed9c6476de7e73fc9b148734">&#9670;&nbsp;</a></span>RTC_PDD_ReadTamperDetectReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTamperDetectReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TDR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Tamper detect register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TDR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#adccf8828ed9c6476de7e73fc9b148734">RTC_PDD_ReadTamperDetectReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7e90a265e9ca0efb22a1d63104fea96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e90a265e9ca0efb22a1d63104fea96a">&#9670;&nbsp;</a></span>RTC_PDD_ReadTamperTimeSecondsReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTamperTimeSecondsReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TTSR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Tamper time seconds register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TTSR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a7e90a265e9ca0efb22a1d63104fea96a">RTC_PDD_ReadTamperTimeSecondsReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab3d852c24e03416dd9d1a46035f8107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d852c24e03416dd9d1a46035f8107f">&#9670;&nbsp;</a></span>RTC_PDD_ReadTamperTrimReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTamperTrimReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TTR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Tamper trim register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TTR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#ab3d852c24e03416dd9d1a46035f8107f">RTC_PDD_ReadTamperTrimReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0ee012d50e404ede78f52b01af76fe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee012d50e404ede78f52b01af76fe4b">&#9670;&nbsp;</a></span>RTC_PDD_ReadTimeAlarmReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTimeAlarmReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TAR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Time alarm register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a0ee012d50e404ede78f52b01af76fe4b">RTC_PDD_ReadTimeAlarmReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07f0a9a5f92353e131c8c29acf4a6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f0a9a5f92353e131c8c29acf4a6dcf">&#9670;&nbsp;</a></span>RTC_PDD_ReadTimeCompensationReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTimeCompensationReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TCR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Time compensation register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TCR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result =</div><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a07f0a9a5f92353e131c8c29acf4a6dcf">RTC_PDD_ReadTimeCompensationReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2e7aa88a1eca9a0a4a8a7230dcf230a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7aa88a1eca9a0a4a8a7230dcf230a6">&#9670;&nbsp;</a></span>RTC_PDD_ReadTimePrescalerReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTimePrescalerReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TPR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Time prescaler register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TPR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#a2e7aa88a1eca9a0a4a8a7230dcf230a6">RTC_PDD_ReadTimePrescalerReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa2ba39ebe33db3dd9f62a96b7d6b186a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ba39ebe33db3dd9f62a96b7d6b186a">&#9670;&nbsp;</a></span>RTC_PDD_ReadTimeSecondsReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadTimeSecondsReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TSR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Time seconds register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TSR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#aa2ba39ebe33db3dd9f62a96b7d6b186a">RTC_PDD_ReadTimeSecondsReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac66613996cca071936533d8706857de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66613996cca071936533d8706857de0">&#9670;&nbsp;</a></span>RTC_PDD_ReadWriteAccessReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_ReadWriteAccessReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Returns the content of the Write access register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32-bit value. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">uint32_t result = <a class="code" href="_r_t_c___p_d_d_8h.html#ac66613996cca071936533d8706857de0">RTC_PDD_ReadWriteAccessReg</a>(&lt;peripheral&gt;_BASE_PTR);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af6df0941f1d939cbb99ac4c44a7da686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6df0941f1d939cbb99ac4c44a7da686">&#9670;&nbsp;</a></span>RTC_PDD_SetRtcInterruptMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_SetRtcInterruptMask</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_IER_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Mask) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables RTC interrupts defined by the Mask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Mask</td><td>Imterrupt mask. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_IER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#af6df0941f1d939cbb99ac4c44a7da686">RTC_PDD_SetRtcInterruptMask</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a207da0b8cb1b702423cfc7bfedbafc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207da0b8cb1b702423cfc7bfedbafc08">&#9670;&nbsp;</a></span>RTC_PDD_SetRtcTamperInterruptMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_SetRtcTamperInterruptMask</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TIR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Mask) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Enables RTC tamper interrupts defined by the Mask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Mask</td><td>Imterrupt mask. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TIR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a207da0b8cb1b702423cfc7bfedbafc08">RTC_PDD_SetRtcTamperInterruptMask</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad3e9f2f0305ca3955e36f5b09a0dd2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e9f2f0305ca3955e36f5b09a0dd2c9">&#9670;&nbsp;</a></span>RTC_PDD_SetWakeUpPinState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_SetWakeUpPinState</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_SR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(<a class="code" href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a>) \</div><div class="line">  )</div><div class="ttc" id="group___x_f1__module_html_ga5d74787dedbc4e11c1ab15bf487e61f8"><div class="ttname"><a href="group___x_f1__module.html#ga5d74787dedbc4e11c1ab15bf487e61f8">State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> XF1.c:129</div></div>
</div><!-- fragment -->
<p>Sets wake-up pin state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">State</td><td>Requested state. This parameter is of "WakeUpPinState constants" type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_SR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#ad3e9f2f0305ca3955e36f5b09a0dd2c9">RTC_PDD_SetWakeUpPinState</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_r_t_c___p_d_d_8h.html#a0e63cd9f06582f50609a7450f7072e21">RTC_PDD_ASSERTED</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a46506be665e801685a1d8d68e38a053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46506be665e801685a1d8d68e38a053d">&#9670;&nbsp;</a></span>RTC_PDD_TAF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_TAF_INT&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#ga8deec41a2823788375ed7b8b63870868">RTC_SR_TAF_MASK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alarm interrupt mask </p>

</div>
</div>
<a id="abb4f80ec20cc1734201d7cecd5260ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4f80ec20cc1734201d7cecd5260ace">&#9670;&nbsp;</a></span>RTC_PDD_TIF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_TIF_INT&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#ga1efc73171f80fa079f4d3aec43f2faab">RTC_SR_TIF_MASK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time invalid interrupt mask </p>

</div>
</div>
<a id="a446474896e80e98138910c35f603437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446474896e80e98138910c35f603437a">&#9670;&nbsp;</a></span>RTC_PDD_TMF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_TMF_INT&#160;&#160;&#160;RTC_TDR_TMF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test mode tamper interrupt mask </p>

</div>
</div>
<a id="af91213da44685a41539f7f391cf7be9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91213da44685a41539f7f391cf7be9a">&#9670;&nbsp;</a></span>RTC_PDD_TOF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_TOF_INT&#160;&#160;&#160;<a class="el" href="group___r_t_c___register___masks.html#gabadca56816c485ca12134cd54a40c010">RTC_SR_TOF_MASK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer overflow interrupt mask </p>

</div>
</div>
<a id="aaef84c5a6ca4b9713e11364b39decc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef84c5a6ca4b9713e11364b39decc3a">&#9670;&nbsp;</a></span>RTC_PDD_TTF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_TTF_INT&#160;&#160;&#160;RTC_TDR_TTF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temperature tamper interrupt mask </p>

</div>
</div>
<a id="aa9f4482580fbc9919e18af00e8241d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f4482580fbc9919e18af00e8241d86">&#9670;&nbsp;</a></span>RTC_PDD_VTF_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_VTF_INT&#160;&#160;&#160;RTC_TDR_VTF_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Volatge tamper interrupt mask </p>

</div>
</div>
<a id="a5f7a9d9f496bbb5ca0097bc043343c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7a9d9f496bbb5ca0097bc043343c93">&#9670;&nbsp;</a></span>RTC_PDD_WriteControlReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_CR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Control register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_CR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a5f7a9d9f496bbb5ca0097bc043343c93">RTC_PDD_WriteControlReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aef472e29a6b17d294c59d1c3034b18c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef472e29a6b17d294c59d1c3034b18c1">&#9670;&nbsp;</a></span>RTC_PDD_WriteLockReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteLockReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_LR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Lock register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Lock register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_LR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aef472e29a6b17d294c59d1c3034b18c1">RTC_PDD_WriteLockReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2df7f7b754db931d38279b3c5ffe0bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df7f7b754db931d38279b3c5ffe0bb4">&#9670;&nbsp;</a></span>RTC_PDD_WriteMonotonicCounterHigReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteMonotonicCounterHigReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MCHR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Monotonic counter high register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Monotonic counter high register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MCHR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a2df7f7b754db931d38279b3c5ffe0bb4">RTC_PDD_WriteMonotonicCounterHigReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a054e742b4e5e61613b13a7b671f5d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054e742b4e5e61613b13a7b671f5d230">&#9670;&nbsp;</a></span>RTC_PDD_WriteMonotonicCounterLowgReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteMonotonicCounterLowgReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MCLR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Monotonic counter low register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Monotonic counter low register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MCLR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a054e742b4e5e61613b13a7b671f5d230">RTC_PDD_WriteMonotonicCounterLowgReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9b2bc03b643c34aa2d838f4940efced1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2bc03b643c34aa2d838f4940efced1">&#9670;&nbsp;</a></span>RTC_PDD_WriteMonotonicEnableReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteMonotonicEnableReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_MER_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Monotonic enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Monotonic enable register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_MER. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a9b2bc03b643c34aa2d838f4940efced1">RTC_PDD_WriteMonotonicEnableReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="add82e4e48e503fcf4251a184ab909ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add82e4e48e503fcf4251a184ab909ddb">&#9670;&nbsp;</a></span>RTC_PDD_WriteReadAccessReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteReadAccessReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_RAR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Read access register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Read access register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_RAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#add82e4e48e503fcf4251a184ab909ddb">RTC_PDD_WriteReadAccessReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3c4cc08551630f3fd29023fb567f585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4cc08551630f3fd29023fb567f585e">&#9670;&nbsp;</a></span>RTC_PDD_WriteStatusReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">      RTC_SR_REG(PeripheralBase) = \</div><div class="line">       (uint32_t)(Value) \</div><div class="line">    )</div></div><!-- fragment -->
<p>Writes value to the Status register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Status register. Use constants from group "Interrupt masks". This parameter is 32 bits wide. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_SR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a3c4cc08551630f3fd29023fb567f585e">RTC_PDD_WriteStatusReg</a>(&lt;peripheral&gt;_BASE_PTR, <a class="code" href="_r_t_c___p_d_d_8h.html#a46506be665e801685a1d8d68e38a053d">RTC_PDD_TAF_INT</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeaac5e04ba0273608be155218f75a343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac5e04ba0273608be155218f75a343">&#9670;&nbsp;</a></span>RTC_PDD_WriteTamperDetectReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTamperDetectReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TDR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Tamper detect register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Tamper detect register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TDR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aeaac5e04ba0273608be155218f75a343">RTC_PDD_WriteTamperDetectReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aafa78b3394ecc51ebc05d31b6b670c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa78b3394ecc51ebc05d31b6b670c05">&#9670;&nbsp;</a></span>RTC_PDD_WriteTamperTrimReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTamperTrimReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TTR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Tamper trim register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Tamper trim register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TTR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#aafa78b3394ecc51ebc05d31b6b670c05">RTC_PDD_WriteTamperTrimReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4bec7545b99e206c42d8673e0705de6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bec7545b99e206c42d8673e0705de6d">&#9670;&nbsp;</a></span>RTC_PDD_WriteTimeAlarmReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTimeAlarmReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TAR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Time alarm register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Time alarm register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a4bec7545b99e206c42d8673e0705de6d">RTC_PDD_WriteTimeAlarmReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afcf1d27bf8728764eb2ad52bd0576c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1d27bf8728764eb2ad52bd0576c12">&#9670;&nbsp;</a></span>RTC_PDD_WriteTimeCompensationReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTimeCompensationReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TCR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Time compensation register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Time compensation register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TCR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#afcf1d27bf8728764eb2ad52bd0576c12">RTC_PDD_WriteTimeCompensationReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a54b9f51c8504efe26e8037a7839e074b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b9f51c8504efe26e8037a7839e074b">&#9670;&nbsp;</a></span>RTC_PDD_WriteTimePrescalerReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTimePrescalerReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TPR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Time prescaler register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Time prescaler register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TPR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a54b9f51c8504efe26e8037a7839e074b">RTC_PDD_WriteTimePrescalerReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3c87ce278c703cc5cdf0cf5a657f6f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c87ce278c703cc5cdf0cf5a657f6f16">&#9670;&nbsp;</a></span>RTC_PDD_WriteTimeSecondsReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteTimeSecondsReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_TSR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Time seconds register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Time seconds register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_TSR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a3c87ce278c703cc5cdf0cf5a657f6f16">RTC_PDD_WriteTimeSecondsReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a80c42e1509ae82a4489512f9ecaa9676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c42e1509ae82a4489512f9ecaa9676">&#9670;&nbsp;</a></span>RTC_PDD_WriteWriteAccessReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PDD_WriteWriteAccessReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PeripheralBase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">    RTC_WAR_REG(PeripheralBase) = \</div><div class="line">     (uint32_t)(Value) \</div><div class="line">  )</div></div><!-- fragment -->
<p>Writes value to the Write access register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeripheralBase</td><td>Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file (&lt;peripheral&gt;_BASE_PTR) or the constant defined in the peripheral initialization component header file (&lt;component_name&gt;_DEVICE). </td></tr>
    <tr><td class="paramname">Value</td><td>Value written to the Write access register. This parameter is a 32-bit value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of void type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The macro accesses the following registers: RTC_WAR. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="_r_t_c___p_d_d_8h.html#a80c42e1509ae82a4489512f9ecaa9676">RTC_PDD_WriteWriteAccessReg</a>(&lt;peripheral&gt;_BASE_PTR, 1);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
