\hypertarget{_r_t_c___p_d_d_8h}{}\section{F\+:/workspace/\+Goods\+Tracker/platform/\+Goods\+Tracker\+Control/\+Static\+\_\+\+Code/\+P\+D\+D/\+R\+T\+C\+\_\+\+P\+DD.h File Reference}
\label{_r_t_c___p_d_d_8h}\index{F\+:/workspace/\+Goods\+Tracker/platform/\+Goods\+Tracker\+Control/\+Static\+\_\+\+Code/\+P\+D\+D/\+R\+T\+C\+\_\+\+P\+D\+D.\+h@{F\+:/workspace/\+Goods\+Tracker/platform/\+Goods\+Tracker\+Control/\+Static\+\_\+\+Code/\+P\+D\+D/\+R\+T\+C\+\_\+\+P\+D\+D.\+h}}
{\ttfamily \#include \char`\"{}P\+D\+D\+\_\+\+Types.\+h\char`\"{}}\newline
Include dependency graph for R\+T\+C\+\_\+\+P\+D\+D.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a46506be665e801685a1d8d68e38a053d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT}~\hyperlink{group___r_t_c___register___masks_ga8deec41a2823788375ed7b8b63870868}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+A\+F\+\_\+\+M\+A\+SK}
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_af91213da44685a41539f7f391cf7be9a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT}~\hyperlink{group___r_t_c___register___masks_gabadca56816c485ca12134cd54a40c010}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+O\+F\+\_\+\+M\+A\+SK}
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_abb4f80ec20cc1734201d7cecd5260ace}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT}~\hyperlink{group___r_t_c___register___masks_ga1efc73171f80fa079f4d3aec43f2faab}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+I\+F\+\_\+\+M\+A\+SK}
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a446474896e80e98138910c35f603437a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+T\+M\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8f5945ae44076fa558f026d928bd71cf}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+F\+S\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aaef84c5a6ca4b9713e11364b39decc3a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+T\+T\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aa611383e95284c75839569bb3bd58195}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+C\+T\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aa9f4482580fbc9919e18af00e8241d86}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+V\+T\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ae25c7f7b278d0a3ced9facc2733e17ca}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT}~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+D\+T\+F\+\_\+\+M\+A\+SK
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0e63cd9f06582f50609a7450f7072e21}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED}~0x8U
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ab384f783d6acffcf3ca2fbd99bd01430}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED}~0U
\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aa2ba39ebe33db3dd9f62a96b7d6b186a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Time seconds register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a3c87ce278c703cc5cdf0cf5a657f6f16}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Time seconds register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2e7aa88a1eca9a0a4a8a7230dcf230a6}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Time prescaler register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a54b9f51c8504efe26e8037a7839e074b}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Time prescaler register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0ee012d50e404ede78f52b01af76fe4b}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Time alarm register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a4bec7545b99e206c42d8673e0705de6d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Time alarm register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a07f0a9a5f92353e131c8c29acf4a6dcf}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Time compensation register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_afcf1d27bf8728764eb2ad52bd0576c12}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Time compensation register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_af08ea06ba509408063e58c9034c1da9d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Control register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a5f7a9d9f496bbb5ca0097bc043343c93}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Control register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a73a34d2e72d1a661b4bbccd5fe4be892}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Enables/disables update mode. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a88f3e11628daff979b256bda935d46e7}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Enables/disables supervisor accesss. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a116eeaa0c821be7394233415fa9dfcdd}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Enables/disables wakeup pin. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a4414955b1ed3d7c4fa6bba0d0db31286}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Forces the equivalent of a V\+B\+AT P\+OR to the rest of the R\+TC module, except the access control registers. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_acc0efeea9283ff1486c8992190b8d772}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the R\+TC interrupt enable register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_af6df0941f1d939cbb99ac4c44a7da686}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask}(Peripheral\+Base,  Mask)
\begin{DoxyCompactList}\small\item\em Enables R\+TC interrupts defined by the Mask parameter. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a52faa25caeec8beb1b16fa433a5fb25c}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Seconds interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a80139a02f86ce73f0bba4eafa5b3dcd9}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Alarm interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ac2f20eea4f7c38e1ca3a38515a2df3af}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Time overflow interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2619e9f0c03f0a59e040a436b1381eac}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Time invalid interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a17829684ce4f1f59e655ae847caf9927}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Seconds interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a4d131732142356708552e11c4beb77cc}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Alarm interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8a17d968ee5bf693d38893e9b23cb08a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Time overflow interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a3ba6f9549f12d7134e6628a9a952d4d5}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Time invalid interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad3e9f2f0305ca3955e36f5b09a0dd2c9}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Sets wake-\/up pin state. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_adad1108af887779b61fedfc47bc127ee}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Status register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a3c4cc08551630f3fd29023fb567f585e}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Status register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a4be4929ed1dd854d124994af7f87e70c}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Enables/disables seconds counter. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a65f0574b7bf84752511f55210108861a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns zero if the Time counter is disabled else return non-\/zero value. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ae19e94746c7370a54d893b716c371c7e}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Lock register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aef472e29a6b17d294c59d1c3034b18c1}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Lock register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a6255de23295c3295d12faf42f7399e0e}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a9e59b86297b061640b66007c4c5b9973}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1c3f99a246c2de3cae96ecb1d5fda91f}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ac66613996cca071936533d8706857de0}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Write access register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a80c42e1509ae82a4489512f9ecaa9676}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Write access register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a79788aec20a515df12bbd8fa897c8c53}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8567d47f3986d85c0a0fd75de6475e90}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1f9da5c8b44ca15f8561006012f36acd}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0c5ada66b03f5df14f47dd59a5fe638c}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0892ba70608c47d68006c04a050cd796}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a98cfc0e18002ac1e69fad3d99c1614c1}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a539d8b1dbb1406f858fdfdc7ee57b962}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aa27fd6674dd8cdfd7240677ce2cfa50a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a3d50bcc8586f48ec668816f02b5335ad}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Read access register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_add82e4e48e503fcf4251a184ab909ddb}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Read access register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ae45ba06e57979f0d9936dd7d2300df9e}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad345b857c1b4b168a1a83f03394deee3}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a11b5fd30b5332504b49121391536e392}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad03e1f943e002bcc0e1dd4de56494207}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aadb79a3573398d99730e1d35ab08a0f0}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8630252239b6aef824823d4a9bbd9dec}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a694ace39432f8d9094170267b9d2dea7}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1506d9aae27f92d67144267b689452a1}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a35e513d2c1fff3dbc1a05b1d0fab9e5d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Monotonic counter overflow interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a14c0fd8323d1e5ecba2b41073a87d35d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Monotonic counter overflow interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0e3bcee818ee0755cd9c4918eca3d992}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2676a73d79f3fad22f4d7550b1eed1ec}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a80a147396e76f79b3c97e1b83bb73357}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a4d02dfe2d1ac5b457aa9f9c21e1b8f15}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a7e90a265e9ca0efb22a1d63104fea96a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Tamper time seconds register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a5d9a3d79b01ddc51b7056c05145fb094}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Tamper time in seconds. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a0c89348f4c6a03bbbdac79c5806c9447}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Monotonic enable register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a9b2bc03b643c34aa2d838f4940efced1}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Monotonic enable register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_acc32248ac0c4f84aed919a6fd1027e75}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter}(Peripheral\+Base,  \hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State})
\begin{DoxyCompactList}\small\item\em Enables/disables Monotonis counter counter. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a34632f9df5ff3798a25844b79fced3e9}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns zero if the Monotonic counter is disabled else return non-\/zero value. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a7fe6c83828ac784abd4d5de65a2408e3}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Monotonic counter high register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2df7f7b754db931d38279b3c5ffe0bb4}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Monotonic counter high register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a30fe2d14dc6d7c908ad30e4840279a09}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Monotonic counter low register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a054e742b4e5e61613b13a7b671f5d230}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Monotonic counter low register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad6daa1b1a5d82d8c09d7db529e321b54}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8174320e8154bba8377005b5383137f1}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad65af00c4825db32b03f15274db38089}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a65c54a567f209ac84af21af9ffac3b4c}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a284bb38a0a11e14671588c4097b0486d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a36be6a8ce903ec3559be645cc8457067}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1158f352d4d461cba3b02e936345fdbc}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aec7d7a47f2738b454353093bf0a8975d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_abdee0a4509d3f3f3dd7503f6cb03d696}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2cfcc219f1aa8dc02f971ecc6cb51d31}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aa4d54aa845cbed8435ed063b294d64a0}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2818d87bf2c89150caafded71f7ae557}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a12c0ca495aab94fc9e9bdbc0ed5f6cac}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the R\+TC tamper interrupt register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a207da0b8cb1b702423cfc7bfedbafc08}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask}(Peripheral\+Base,  Mask)
\begin{DoxyCompactList}\small\item\em Enables R\+TC tamper interrupts defined by the Mask parameter. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a5db18f95e0cb1e1460d9863958adc777}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Test mode interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_af7f4edb2c6652c7587b7bcd9044f4e3b}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Flash security interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a5a014d6b3d4146d786e8e6e21859af7a}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Temperature tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ab59be43120e97a1050e6cc053cc61013}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Clock tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a8b9ae01a02f8531d3369dcf8067a3d9f}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Voltage tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a3bae7ae5f7466e804e7367d2bdba0953}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Enables the Dry\+Ice tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2c4a870b62fdb57dfac8a61b484a93e8}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Test mode interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a49b5e16c8619bbd5000b78ebf2db11f6}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Flash security interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a76787b69116b49507018cb2675655366}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Temperature tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1493bc2bfe7fc51d09a10aedef90fbc6}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Clock tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aef041e8778c3547cff3ea48311757a86}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Voltage tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ac66495c7f93965d8b5b0ef69d6198e97}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables the Dry\+Ice tamper interrupt. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_adccf8828ed9c6476de7e73fc9b148734}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Tamper detect register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aeaac5e04ba0273608be155218f75a343}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Tamper detect register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ad95e6be41bc311d05429db8fd281b290}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aea3a03785b7f61e1f957f859e20f9076}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a982db75db757024580c0d1d34b338b31}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a6f049a68a37b632ba0094e446317366c}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_ab3d852c24e03416dd9d1a46035f8107f}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Returns the content of the Tamper trim register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_aafa78b3394ecc51ebc05d31b6b670c05}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg}(Peripheral\+Base,  Value)
\begin{DoxyCompactList}\small\item\em Writes value to the Tamper trim register. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_adb8598e0b6c45332bb113c9fdccbd964}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a1ce699326b57cc048926082304305a5d}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2c3234ac48984d0f3136eac89ec6c8e5}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\item 
\#define \hyperlink{_r_t_c___p_d_d_8h_a2dbdd2b1702701956b01496b1f79b885}{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read}(Peripheral\+Base)
\begin{DoxyCompactList}\small\item\em Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0e63cd9f06582f50609a7450f7072e21}\label{_r_t_c___p_d_d_8h_a0e63cd9f06582f50609a7450f7072e21}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED}{RTC\_PDD\_ASSERTED}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+A\+S\+S\+E\+R\+T\+ED~0x8U}

Pin is asserted \mbox{\Hypertarget{_r_t_c___p_d_d_8h_aa611383e95284c75839569bb3bd58195}\label{_r_t_c___p_d_d_8h_aa611383e95284c75839569bb3bd58195}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT}{RTC\_PDD\_CTF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+C\+T\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+C\+T\+F\+\_\+\+M\+A\+SK}

Clock tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_a4d131732142356708552e11c4beb77cc}\label{_r_t_c___p_d_d_8h_a4d131732142356708552e11c4beb77cc}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt}{RTC\_PDD\_DisableAlarmInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Alarm\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_gad1bcc4df9a637ec5ab4b611391986c06}{RTC\_IER\_TAIE\_MASK}) \(\backslash\)
  )
\end{DoxyCode}


Disables the Alarm interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a4d131732142356708552e11c4beb77cc}{RTC\_PDD\_DisableAlarmInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1493bc2bfe7fc51d09a10aedef90fbc6}\label{_r_t_c___p_d_d_8h_a1493bc2bfe7fc51d09a10aedef90fbc6}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt}{RTC\_PDD\_DisableClockTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Clock\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_CTIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Clock tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1493bc2bfe7fc51d09a10aedef90fbc6}{RTC\_PDD\_DisableClockTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad03e1f943e002bcc0e1dd4de56494207}\label{_r_t_c___p_d_d_8h_ad03e1f943e002bcc0e1dd4de56494207}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read}{RTC\_PDD\_DisableControlRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_CRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad03e1f943e002bcc0e1dd4de56494207}{RTC\_PDD\_DisableControlRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0c5ada66b03f5df14f47dd59a5fe638c}\label{_r_t_c___p_d_d_8h_a0c5ada66b03f5df14f47dd59a5fe638c}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write}{RTC\_PDD\_DisableControlRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Control\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_CRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a0c5ada66b03f5df14f47dd59a5fe638c}{RTC\_PDD\_DisableControlRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ac66495c7f93965d8b5b0ef69d6198e97}\label{_r_t_c___p_d_d_8h_ac66495c7f93965d8b5b0ef69d6198e97}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt}{RTC\_PDD\_DisableDryIceTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Dry\+Ice\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_DTIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Dry\+Ice tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ac66495c7f93965d8b5b0ef69d6198e97}{RTC\_PDD\_DisableDryIceTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a49b5e16c8619bbd5000b78ebf2db11f6}\label{_r_t_c___p_d_d_8h_a49b5e16c8619bbd5000b78ebf2db11f6}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt}{RTC\_PDD\_DisableFlashSecurityInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Flash\+Security\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_FSIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Flash security interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a49b5e16c8619bbd5000b78ebf2db11f6}{RTC\_PDD\_DisableFlashSecurityInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ae45ba06e57979f0d9936dd7d2300df9e}\label{_r_t_c___p_d_d_8h_ae45ba06e57979f0d9936dd7d2300df9e}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read}{RTC\_PDD\_DisableInterruptEnableRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_IERR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ae45ba06e57979f0d9936dd7d2300df9e}{RTC\_PDD\_DisableInterruptEnableRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a79788aec20a515df12bbd8fa897c8c53}\label{_r_t_c___p_d_d_8h_a79788aec20a515df12bbd8fa897c8c53}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write}{RTC\_PDD\_DisableInterruptEnableRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Interrupt\+Enable\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_IERW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a79788aec20a515df12bbd8fa897c8c53}{RTC\_PDD\_DisableInterruptEnableRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad345b857c1b4b168a1a83f03394deee3}\label{_r_t_c___p_d_d_8h_ad345b857c1b4b168a1a83f03394deee3}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read}{RTC\_PDD\_DisableLockRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_LRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad345b857c1b4b168a1a83f03394deee3}{RTC\_PDD\_DisableLockRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8567d47f3986d85c0a0fd75de6475e90}\label{_r_t_c___p_d_d_8h_a8567d47f3986d85c0a0fd75de6475e90}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write}{RTC\_PDD\_DisableLockRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Lock\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_LRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a8567d47f3986d85c0a0fd75de6475e90}{RTC\_PDD\_DisableLockRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a284bb38a0a11e14671588c4097b0486d}\label{_r_t_c___p_d_d_8h_a284bb38a0a11e14671588c4097b0486d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read}{RTC\_PDD\_DisableMonotonicCounterHighRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_MCHR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a284bb38a0a11e14671588c4097b0486d}{RTC\_PDD\_DisableMonotonicCounterHighRegRead}(<peripheral>\_BASE\_PTR)
      ;
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad6daa1b1a5d82d8c09d7db529e321b54}\label{_r_t_c___p_d_d_8h_ad6daa1b1a5d82d8c09d7db529e321b54}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write}{RTC\_PDD\_DisableMonotonicCounterHighRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+High\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_MCHW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad6daa1b1a5d82d8c09d7db529e321b54}{RTC\_PDD\_DisableMonotonicCounterHighRegWrite}(<peripheral>
      \_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a36be6a8ce903ec3559be645cc8457067}\label{_r_t_c___p_d_d_8h_a36be6a8ce903ec3559be645cc8457067}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read}{RTC\_PDD\_DisableMonotonicCounterLowRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_MCLR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a36be6a8ce903ec3559be645cc8457067}{RTC\_PDD\_DisableMonotonicCounterLowRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8174320e8154bba8377005b5383137f1}\label{_r_t_c___p_d_d_8h_a8174320e8154bba8377005b5383137f1}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write}{RTC\_PDD\_DisableMonotonicCounterLowRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Counter\+Low\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_MCLW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a8174320e8154bba8377005b5383137f1}{RTC\_PDD\_DisableMonotonicCounterLowRegWrite}(<peripheral>\_BASE\_PTR)
      ;
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1158f352d4d461cba3b02e936345fdbc}\label{_r_t_c___p_d_d_8h_a1158f352d4d461cba3b02e936345fdbc}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read}{RTC\_PDD\_DisableMonotonicEnableRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_MERR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1158f352d4d461cba3b02e936345fdbc}{RTC\_PDD\_DisableMonotonicEnableRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad65af00c4825db32b03f15274db38089}\label{_r_t_c___p_d_d_8h_ad65af00c4825db32b03f15274db38089}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write}{RTC\_PDD\_DisableMonotonicEnableRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Enable\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_MERW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad65af00c4825db32b03f15274db38089}{RTC\_PDD\_DisableMonotonicEnableRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a14c0fd8323d1e5ecba2b41073a87d35d}\label{_r_t_c___p_d_d_8h_a14c0fd8323d1e5ecba2b41073a87d35d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt}{RTC\_PDD\_DisableMonotonicOverflowInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Monotonic\+Overflow\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_IER\_MOIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Monotonic counter overflow interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a14c0fd8323d1e5ecba2b41073a87d35d}{RTC\_PDD\_DisableMonotonicOverflowInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a17829684ce4f1f59e655ae847caf9927}\label{_r_t_c___p_d_d_8h_a17829684ce4f1f59e655ae847caf9927}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt}{RTC\_PDD\_DisableSecondsInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Seconds\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga63c8ae5db82845d5bb13907cd0e70cd7}{RTC\_IER\_TSIE\_MASK}) \(\backslash\)
  )
\end{DoxyCode}


Disables the Seconds interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a17829684ce4f1f59e655ae847caf9927}{RTC\_PDD\_DisableSecondsInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a11b5fd30b5332504b49121391536e392}\label{_r_t_c___p_d_d_8h_a11b5fd30b5332504b49121391536e392}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read}{RTC\_PDD\_DisableStatusRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_SRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a11b5fd30b5332504b49121391536e392}{RTC\_PDD\_DisableStatusRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1f9da5c8b44ca15f8561006012f36acd}\label{_r_t_c___p_d_d_8h_a1f9da5c8b44ca15f8561006012f36acd}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write}{RTC\_PDD\_DisableStatusRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Status\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_SRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1f9da5c8b44ca15f8561006012f36acd}{RTC\_PDD\_DisableStatusRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2c3234ac48984d0f3136eac89ec6c8e5}\label{_r_t_c___p_d_d_8h_a2c3234ac48984d0f3136eac89ec6c8e5}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read}{RTC\_PDD\_DisableTamperDetectRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_RAR\_TDRR\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2c3234ac48984d0f3136eac89ec6c8e5}{RTC\_PDD\_DisableTamperDetectRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a982db75db757024580c0d1d34b338b31}\label{_r_t_c___p_d_d_8h_a982db75db757024580c0d1d34b338b31}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write}{RTC\_PDD\_DisableTamperDetectRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Detect\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_WAR\_TDRW\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a982db75db757024580c0d1d34b338b31}{RTC\_PDD\_DisableTamperDetectRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2dbdd2b1702701956b01496b1f79b885}\label{_r_t_c___p_d_d_8h_a2dbdd2b1702701956b01496b1f79b885}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read}{RTC\_PDD\_DisableTamperEnableRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_RAR\_TERR\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2dbdd2b1702701956b01496b1f79b885}{RTC\_PDD\_DisableTamperEnableRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a6f049a68a37b632ba0094e446317366c}\label{_r_t_c___p_d_d_8h_a6f049a68a37b632ba0094e446317366c}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write}{RTC\_PDD\_DisableTamperEnableRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Enable\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_WAR\_TERW\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a6f049a68a37b632ba0094e446317366c}{RTC\_PDD\_DisableTamperEnableRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_adb8598e0b6c45332bb113c9fdccbd964}\label{_r_t_c___p_d_d_8h_adb8598e0b6c45332bb113c9fdccbd964}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read}{RTC\_PDD\_DisableTamperInterruptRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_RAR\_TIRR\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_adb8598e0b6c45332bb113c9fdccbd964}{RTC\_PDD\_DisableTamperInterruptRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad95e6be41bc311d05429db8fd281b290}\label{_r_t_c___p_d_d_8h_ad95e6be41bc311d05429db8fd281b290}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write}{RTC\_PDD\_DisableTamperInterruptRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Interrupt\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_WAR\_TIRW\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad95e6be41bc311d05429db8fd281b290}{RTC\_PDD\_DisableTamperInterruptRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aec7d7a47f2738b454353093bf0a8975d}\label{_r_t_c___p_d_d_8h_aec7d7a47f2738b454353093bf0a8975d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read}{RTC\_PDD\_DisableTamperTimeSecondsRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_TTSR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aec7d7a47f2738b454353093bf0a8975d}{RTC\_PDD\_DisableTamperTimeSecondsRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a65c54a567f209ac84af21af9ffac3b4c}\label{_r_t_c___p_d_d_8h_a65c54a567f209ac84af21af9ffac3b4c}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write}{RTC\_PDD\_DisableTamperTimeSecondsRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Time\+Seconds\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_TTSW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a65c54a567f209ac84af21af9ffac3b4c}{RTC\_PDD\_DisableTamperTimeSecondsRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1ce699326b57cc048926082304305a5d}\label{_r_t_c___p_d_d_8h_a1ce699326b57cc048926082304305a5d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read}{RTC\_PDD\_DisableTamperTrimRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_RAR\_TTRR\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1ce699326b57cc048926082304305a5d}{RTC\_PDD\_DisableTamperTrimRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aea3a03785b7f61e1f957f859e20f9076}\label{_r_t_c___p_d_d_8h_aea3a03785b7f61e1f957f859e20f9076}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write}{RTC\_PDD\_DisableTamperTrimRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Tamper\+Trim\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_WAR\_TTRW\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aea3a03785b7f61e1f957f859e20f9076}{RTC\_PDD\_DisableTamperTrimRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a76787b69116b49507018cb2675655366}\label{_r_t_c___p_d_d_8h_a76787b69116b49507018cb2675655366}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt}{RTC\_PDD\_DisableTemperatureTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Temperature\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_TTIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Temperature tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a76787b69116b49507018cb2675655366}{RTC\_PDD\_DisableTemperatureTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2c4a870b62fdb57dfac8a61b484a93e8}\label{_r_t_c___p_d_d_8h_a2c4a870b62fdb57dfac8a61b484a93e8}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt}{RTC\_PDD\_DisableTestModeInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Test\+Mode\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_TMIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Test mode interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2c4a870b62fdb57dfac8a61b484a93e8}{RTC\_PDD\_DisableTestModeInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8630252239b6aef824823d4a9bbd9dec}\label{_r_t_c___p_d_d_8h_a8630252239b6aef824823d4a9bbd9dec}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read}{RTC\_PDD\_DisableTimeAlarmRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_TARR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a8630252239b6aef824823d4a9bbd9dec}{RTC\_PDD\_DisableTimeAlarmRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a98cfc0e18002ac1e69fad3d99c1614c1}\label{_r_t_c___p_d_d_8h_a98cfc0e18002ac1e69fad3d99c1614c1}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write}{RTC\_PDD\_DisableTimeAlarmRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Alarm\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_TARW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a98cfc0e18002ac1e69fad3d99c1614c1}{RTC\_PDD\_DisableTimeAlarmRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aadb79a3573398d99730e1d35ab08a0f0}\label{_r_t_c___p_d_d_8h_aadb79a3573398d99730e1d35ab08a0f0}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read}{RTC\_PDD\_DisableTimeCompensationRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_TCRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aadb79a3573398d99730e1d35ab08a0f0}{RTC\_PDD\_DisableTimeCompensationRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0892ba70608c47d68006c04a050cd796}\label{_r_t_c___p_d_d_8h_a0892ba70608c47d68006c04a050cd796}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write}{RTC\_PDD\_DisableTimeCompensationRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Compensation\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_TCRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a0892ba70608c47d68006c04a050cd796}{RTC\_PDD\_DisableTimeCompensationRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a3ba6f9549f12d7134e6628a9a952d4d5}\label{_r_t_c___p_d_d_8h_a3ba6f9549f12d7134e6628a9a952d4d5}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt}{RTC\_PDD\_DisableTimeInvalidInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Invalid\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga4401cd4dce34a638f75403a2a3701e6d}{RTC\_IER\_TIIE\_MASK}) \(\backslash\)
  )
\end{DoxyCode}


Disables the Time invalid interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a3ba6f9549f12d7134e6628a9a952d4d5}{RTC\_PDD\_DisableTimeInvalidInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8a17d968ee5bf693d38893e9b23cb08a}\label{_r_t_c___p_d_d_8h_a8a17d968ee5bf693d38893e9b23cb08a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt}{RTC\_PDD\_DisableTimeOverflowInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Overflow\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga1dfc25308bec00f67925ae796f805d3d}{RTC\_IER\_TOIE\_MASK}) \(\backslash\)
  )
\end{DoxyCode}


Disables the Time overflow interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a8a17d968ee5bf693d38893e9b23cb08a}{RTC\_PDD\_DisableTimeOverflowInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a694ace39432f8d9094170267b9d2dea7}\label{_r_t_c___p_d_d_8h_a694ace39432f8d9094170267b9d2dea7}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read}{RTC\_PDD\_DisableTimePrescalerRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_TPRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a694ace39432f8d9094170267b9d2dea7}{RTC\_PDD\_DisableTimePrescalerRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a539d8b1dbb1406f858fdfdc7ee57b962}\label{_r_t_c___p_d_d_8h_a539d8b1dbb1406f858fdfdc7ee57b962}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write}{RTC\_PDD\_DisableTimePrescalerRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Prescaler\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_TPRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a539d8b1dbb1406f858fdfdc7ee57b962}{RTC\_PDD\_DisableTimePrescalerRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1506d9aae27f92d67144267b689452a1}\label{_r_t_c___p_d_d_8h_a1506d9aae27f92d67144267b689452a1}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read}{RTC\_PDD\_DisableTimeSecondsRegRead}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Read(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_RAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_RAR\_TSRR\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables read accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1506d9aae27f92d67144267b689452a1}{RTC\_PDD\_DisableTimeSecondsRegRead}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aa27fd6674dd8cdfd7240677ce2cfa50a}\label{_r_t_c___p_d_d_8h_aa27fd6674dd8cdfd7240677ce2cfa50a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write}{RTC\_PDD\_DisableTimeSecondsRegWrite}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Time\+Seconds\+Reg\+Write(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_WAR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_WAR\_TSRW\_MASK) \(\backslash\)
    )
\end{DoxyCode}


Disables write accesses to the register until the next chip system reset. When accesses are blocked the bus access is not seen in the V\+B\+AT power supply and does not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aa27fd6674dd8cdfd7240677ce2cfa50a}{RTC\_PDD\_DisableTimeSecondsRegWrite}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aef041e8778c3547cff3ea48311757a86}\label{_r_t_c___p_d_d_8h_aef041e8778c3547cff3ea48311757a86}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt}{RTC\_PDD\_DisableVolatgeTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Disable\+Volatge\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_TIR\_VTIE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Disables the Voltage tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aef041e8778c3547cff3ea48311757a86}{RTC\_PDD\_DisableVolatgeTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ae25c7f7b278d0a3ced9facc2733e17ca}\label{_r_t_c___p_d_d_8h_ae25c7f7b278d0a3ced9facc2733e17ca}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT}{RTC\_PDD\_DTF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+D\+T\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+D\+T\+F\+\_\+\+M\+A\+SK}

Dry\+Ice tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_a80139a02f86ce73f0bba4eafa5b3dcd9}\label{_r_t_c___p_d_d_8h_a80139a02f86ce73f0bba4eafa5b3dcd9}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt}{RTC\_PDD\_EnableAlarmInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Alarm\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_IER\_TAIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Alarm interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a80139a02f86ce73f0bba4eafa5b3dcd9}{RTC\_PDD\_EnableAlarmInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ab59be43120e97a1050e6cc053cc61013}\label{_r_t_c___p_d_d_8h_ab59be43120e97a1050e6cc053cc61013}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt}{RTC\_PDD\_EnableClockTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Clock\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_CTIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Clock tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ab59be43120e97a1050e6cc053cc61013}{RTC\_PDD\_EnableClockTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a4be4929ed1dd854d124994af7f87e70c}\label{_r_t_c___p_d_d_8h_a4be4929ed1dd854d124994af7f87e70c}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter}{RTC\_PDD\_EnableCounter}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Counter(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    ((\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) == \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE}) ? ( \(\backslash\)
      RTC\_SR\_REG(PeripheralBase) = \(\backslash\)
       0U) : ( \(\backslash\)
      \hyperlink{group___r_t_c___register___accessor___macros_gab87ebfc55a2b4e49ef0c0a52819e27b0}{RTC\_SR\_REG}(PeripheralBase) = \(\backslash\)
       0x10U) \(\backslash\)
  )
\end{DoxyCode}


Enables/disables seconds counter. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (P\+D\+D\+\_\+\+D\+I\+S\+A\+B\+LE and P\+D\+D\+\_\+\+E\+N\+A\+B\+LE defined in \hyperlink{_p_d_d___types_8h}{P\+D\+D\+\_\+\+Types.\+h})" type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a4be4929ed1dd854d124994af7f87e70c}{RTC\_PDD\_EnableCounter}(<peripheral>\_BASE\_PTR, \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a3bae7ae5f7466e804e7367d2bdba0953}\label{_r_t_c___p_d_d_8h_a3bae7ae5f7466e804e7367d2bdba0953}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt}{RTC\_PDD\_EnableDryIceTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Dry\+Ice\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_DTIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Dry\+Ice tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a3bae7ae5f7466e804e7367d2bdba0953}{RTC\_PDD\_EnableDryIceTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_af7f4edb2c6652c7587b7bcd9044f4e3b}\label{_r_t_c___p_d_d_8h_af7f4edb2c6652c7587b7bcd9044f4e3b}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt}{RTC\_PDD\_EnableFlashSecurityInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Flash\+Security\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_FSIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Flash security interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_af7f4edb2c6652c7587b7bcd9044f4e3b}{RTC\_PDD\_EnableFlashSecurityInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_acc32248ac0c4f84aed919a6fd1027e75}\label{_r_t_c___p_d_d_8h_acc32248ac0c4f84aed919a6fd1027e75}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter}{RTC\_PDD\_EnableMonotonicCounter}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Counter(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    ((\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) == \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE}) ? ( \(\backslash\)
      RTC\_MER\_REG(PeripheralBase) = \(\backslash\)
       0U) : ( \(\backslash\)
      RTC\_MER\_REG(PeripheralBase) = \(\backslash\)
       0x10U) \(\backslash\)
  )
\end{DoxyCode}


Enables/disables Monotonis counter counter. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (P\+D\+D\+\_\+\+D\+I\+S\+A\+B\+LE and P\+D\+D\+\_\+\+E\+N\+A\+B\+LE defined in \hyperlink{_p_d_d___types_8h}{P\+D\+D\+\_\+\+Types.\+h})" type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_acc32248ac0c4f84aed919a6fd1027e75}{RTC\_PDD\_EnableMonotonicCounter}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a35e513d2c1fff3dbc1a05b1d0fab9e5d}\label{_r_t_c___p_d_d_8h_a35e513d2c1fff3dbc1a05b1d0fab9e5d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt}{RTC\_PDD\_EnableMonotonicOverflowInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Monotonic\+Overflow\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_IER\_MOIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Monotonic counter overflow interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a35e513d2c1fff3dbc1a05b1d0fab9e5d}{RTC\_PDD\_EnableMonotonicOverflowInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a52faa25caeec8beb1b16fa433a5fb25c}\label{_r_t_c___p_d_d_8h_a52faa25caeec8beb1b16fa433a5fb25c}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt}{RTC\_PDD\_EnableSecondsInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Seconds\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_IER\_TSIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Seconds interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a52faa25caeec8beb1b16fa433a5fb25c}{RTC\_PDD\_EnableSecondsInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a88f3e11628daff979b256bda935d46e7}\label{_r_t_c___p_d_d_8h_a88f3e11628daff979b256bda935d46e7}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access}{RTC\_PDD\_EnableSupervisorAccess}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Supervisor\+Access(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    ((\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) == \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE}) ? ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) = \(\backslash\)
       (uint32\_t)(( \(\backslash\)
        (uint32\_t)(\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) | \hyperlink{group___r_t_c___register___masks_ga762afd0d0e0bbc08b631a10c45222797}{RTC\_CR\_SUP\_MASK})) & ( \(\backslash\)
        (uint32\_t)(~(uint32\_t)0x4000U)))) : ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)((uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga762afd0d0e0bbc08b631a10c45222797}{RTC\_CR\_SUP\_MASK}) & (uint32\_t)(~(uint32\_t)0x4000U))) 
      \(\backslash\)
  )
\end{DoxyCode}


Enables/disables supervisor accesss. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (P\+D\+D\+\_\+\+D\+I\+S\+A\+B\+LE and P\+D\+D\+\_\+\+E\+N\+A\+B\+LE defined in \hyperlink{_p_d_d___types_8h}{P\+D\+D\+\_\+\+Types.\+h})" type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a88f3e11628daff979b256bda935d46e7}{RTC\_PDD\_EnableSupervisorAccess}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a5a014d6b3d4146d786e8e6e21859af7a}\label{_r_t_c___p_d_d_8h_a5a014d6b3d4146d786e8e6e21859af7a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt}{RTC\_PDD\_EnableTemperatureTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Temperature\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_TTIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Temperature tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a5a014d6b3d4146d786e8e6e21859af7a}{RTC\_PDD\_EnableTemperatureTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a5db18f95e0cb1e1460d9863958adc777}\label{_r_t_c___p_d_d_8h_a5db18f95e0cb1e1460d9863958adc777}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt}{RTC\_PDD\_EnableTestModeInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Test\+Mode\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_TMIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Test mode interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a5db18f95e0cb1e1460d9863958adc777}{RTC\_PDD\_EnableTestModeInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2619e9f0c03f0a59e040a436b1381eac}\label{_r_t_c___p_d_d_8h_a2619e9f0c03f0a59e040a436b1381eac}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt}{RTC\_PDD\_EnableTimeInvalidInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Invalid\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_IER\_TIIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Time invalid interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2619e9f0c03f0a59e040a436b1381eac}{RTC\_PDD\_EnableTimeInvalidInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ac2f20eea4f7c38e1ca3a38515a2df3af}\label{_r_t_c___p_d_d_8h_ac2f20eea4f7c38e1ca3a38515a2df3af}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt}{RTC\_PDD\_EnableTimeOverflowInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Time\+Overflow\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_IER\_TOIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Time overflow interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ac2f20eea4f7c38e1ca3a38515a2df3af}{RTC\_PDD\_EnableTimeOverflowInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a73a34d2e72d1a661b4bbccd5fe4be892}\label{_r_t_c___p_d_d_8h_a73a34d2e72d1a661b4bbccd5fe4be892}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode}{RTC\_PDD\_EnableUpdateMode}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Update\+Mode(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    ((\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) == \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE}) ? ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) = \(\backslash\)
       (uint32\_t)(( \(\backslash\)
        (uint32\_t)(\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) | \hyperlink{group___r_t_c___register___masks_gae071fafa245264dd485258198b7fcf8a}{RTC\_CR\_UM\_MASK})) & ( \(\backslash\)
        (uint32\_t)(~(uint32\_t)0x4000U)))) : ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)((uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_gae071fafa245264dd485258198b7fcf8a}{RTC\_CR\_UM\_MASK}) & (uint32\_t)(~(uint32\_t)0x4000U))) \(\backslash\)
  )
\end{DoxyCode}


Enables/disables update mode. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (P\+D\+D\+\_\+\+D\+I\+S\+A\+B\+LE and P\+D\+D\+\_\+\+E\+N\+A\+B\+LE defined in \hyperlink{_p_d_d___types_8h}{P\+D\+D\+\_\+\+Types.\+h})" type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a73a34d2e72d1a661b4bbccd5fe4be892}{RTC\_PDD\_EnableUpdateMode}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8b9ae01a02f8531d3369dcf8067a3d9f}\label{_r_t_c___p_d_d_8h_a8b9ae01a02f8531d3369dcf8067a3d9f}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt}{RTC\_PDD\_EnableVolatgeTamperInterrupt}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Volatge\+Tamper\+Interrupt(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) |= \(\backslash\)
     RTC\_TIR\_VTIE\_MASK \(\backslash\)
  )
\end{DoxyCode}


Enables the Voltage tamper interrupt. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a8b9ae01a02f8531d3369dcf8067a3d9f}{RTC\_PDD\_EnableVolatgeTamperInterrupt}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a116eeaa0c821be7394233415fa9dfcdd}\label{_r_t_c___p_d_d_8h_a116eeaa0c821be7394233415fa9dfcdd}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin}{RTC\_PDD\_EnableWakeupPin}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Enable\+Wakeup\+Pin(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    ((\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) == \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE}) ? ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) = \(\backslash\)
       (uint32\_t)(( \(\backslash\)
        (uint32\_t)(\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) | \hyperlink{group___r_t_c___register___masks_gade2b0c86902f83d7674c10e3a7923f80}{RTC\_CR\_WPE\_MASK})) & ( \(\backslash\)
        (uint32\_t)(~(uint32\_t)0x4000U)))) : ( \(\backslash\)
      RTC\_CR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)((uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_gade2b0c86902f83d7674c10e3a7923f80}{RTC\_CR\_WPE\_MASK}) & (uint32\_t)(~(uint32\_t)0x4000U))) 
      \(\backslash\)
  )
\end{DoxyCode}


Enables/disables wakeup pin. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of "Global enumeration used for specifying general enable/disable states (P\+D\+D\+\_\+\+D\+I\+S\+A\+B\+LE and P\+D\+D\+\_\+\+E\+N\+A\+B\+LE defined in \hyperlink{_p_d_d___types_8h}{P\+D\+D\+\_\+\+Types.\+h})" type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a116eeaa0c821be7394233415fa9dfcdd}{RTC\_PDD\_EnableWakeupPin}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_p_d_d___types_8h_ab3f067bf9b5f1a0bee256df53023a37f}{PDD\_DISABLE});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a4414955b1ed3d7c4fa6bba0d0db31286}\label{_r_t_c___p_d_d_8h_a4414955b1ed3d7c4fa6bba0d0db31286}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset}{RTC\_PDD\_ForceSwReset}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Force\+Sw\+Reset(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    (\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) = \(\backslash\)
     (uint32\_t)(( \(\backslash\)
      (uint32\_t)(\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) | \hyperlink{group___r_t_c___register___masks_ga114a670a6ac2782bd777ea33e4395059}{RTC\_CR\_SWR\_MASK})) & ( \(\backslash\)
      (uint32\_t)(~(uint32\_t)0x4000U)))), \(\backslash\)
    (\hyperlink{group___r_t_c___register___accessor___macros_ga32aa9fd38e099ee1a01f094e5389a794}{RTC\_CR\_REG}(PeripheralBase) &= \(\backslash\)
     (uint32\_t)((uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga114a670a6ac2782bd777ea33e4395059}{RTC\_CR\_SWR\_MASK}) & (uint32\_t)(~(uint32\_t)0x4000U))) \(\backslash\)
  )
\end{DoxyCode}


Forces the equivalent of a V\+B\+AT P\+OR to the rest of the R\+TC module, except the access control registers. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a4414955b1ed3d7c4fa6bba0d0db31286}{RTC\_PDD\_ForceSwReset}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a8f5945ae44076fa558f026d928bd71cf}\label{_r_t_c___p_d_d_8h_a8f5945ae44076fa558f026d928bd71cf}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT}{RTC\_PDD\_FSF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+F\+S\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+F\+S\+F\+\_\+\+M\+A\+SK}

Flash security tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_a65f0574b7bf84752511f55210108861a}\label{_r_t_c___p_d_d_8h_a65f0574b7bf84752511f55210108861a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status}{RTC\_PDD\_GetEnableCounterStatus}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Enable\+Counter\+Status(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    (uint32\_t)(\hyperlink{group___r_t_c___register___accessor___macros_gab87ebfc55a2b4e49ef0c0a52819e27b0}{RTC\_SR\_REG}(PeripheralBase) & \hyperlink{group___r_t_c___register___masks_gabcb29faa7aa3cee888e06e6b08236907}{RTC\_SR\_TCE\_MASK}) \(\backslash\)
  )
\end{DoxyCode}


Returns zero if the Time counter is disabled else return non-\/zero value. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a65f0574b7bf84752511f55210108861a}{RTC\_PDD\_GetEnableCounterStatus}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a34632f9df5ff3798a25844b79fced3e9}\label{_r_t_c___p_d_d_8h_a34632f9df5ff3798a25844b79fced3e9}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status}{RTC\_PDD\_GetMonotonicCounterEnableStatus}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Monotonic\+Counter\+Enable\+Status(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    (uint32\_t)(RTC\_MER\_REG(PeripheralBase) & RTC\_MER\_MCE\_MASK) \(\backslash\)
  )
\end{DoxyCode}


Returns zero if the Monotonic counter is disabled else return non-\/zero value. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a34632f9df5ff3798a25844b79fced3e9}{RTC\_PDD\_GetMonotonicCounterEnableStatus}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_acc0efeea9283ff1486c8992190b8d772}\label{_r_t_c___p_d_d_8h_acc0efeea9283ff1486c8992190b8d772}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask}{RTC\_PDD\_GetRtcInterruptMask}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Interrupt\+Mask(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the R\+TC interrupt enable register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_acc0efeea9283ff1486c8992190b8d772}{RTC\_PDD\_GetRtcInterruptMask}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a12c0ca495aab94fc9e9bdbc0ed5f6cac}\label{_r_t_c___p_d_d_8h_a12c0ca495aab94fc9e9bdbc0ed5f6cac}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask}{RTC\_PDD\_GetRtcTamperInterruptMask}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Rtc\+Tamper\+Interrupt\+Mask(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the R\+TC tamper interrupt register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a12c0ca495aab94fc9e9bdbc0ed5f6cac}{RTC\_PDD\_GetRtcTamperInterruptMask}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a5d9a3d79b01ddc51b7056c05145fb094}\label{_r_t_c___p_d_d_8h_a5d9a3d79b01ddc51b7056c05145fb094}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time}{RTC\_PDD\_GetTamperTime}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Get\+Tamper\+Time(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TTSR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Tamper time in seconds. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+T\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a5d9a3d79b01ddc51b7056c05145fb094}{RTC\_PDD\_GetTamperTime}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a9e59b86297b061640b66007c4c5b9973}\label{_r_t_c___p_d_d_8h_a9e59b86297b061640b66007c4c5b9973}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg}{RTC\_PDD\_LockControlReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Control\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga79d7286374cccca93261d4ced777c2e7}{RTC\_LR\_CRL\_MASK}) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a9e59b86297b061640b66007c4c5b9973}{RTC\_PDD\_LockControlReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0e3bcee818ee0755cd9c4918eca3d992}\label{_r_t_c___p_d_d_8h_a0e3bcee818ee0755cd9c4918eca3d992}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg}{RTC\_PDD\_LockMonotonicCounterHighReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+High\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_LR\_MCHL\_MASK) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a0e3bcee818ee0755cd9c4918eca3d992}{RTC\_PDD\_LockMonotonicCounterHighReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2676a73d79f3fad22f4d7550b1eed1ec}\label{_r_t_c___p_d_d_8h_a2676a73d79f3fad22f4d7550b1eed1ec}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg}{RTC\_PDD\_LockMonotonicCounterLowReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Counter\+Low\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_LR\_MCLL\_MASK) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2676a73d79f3fad22f4d7550b1eed1ec}{RTC\_PDD\_LockMonotonicCounterLowReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a80a147396e76f79b3c97e1b83bb73357}\label{_r_t_c___p_d_d_8h_a80a147396e76f79b3c97e1b83bb73357}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg}{RTC\_PDD\_LockMonotonicEnableReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Monotonic\+Enable\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_LR\_MEL\_MASK) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a80a147396e76f79b3c97e1b83bb73357}{RTC\_PDD\_LockMonotonicEnableReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a6255de23295c3295d12faf42f7399e0e}\label{_r_t_c___p_d_d_8h_a6255de23295c3295d12faf42f7399e0e}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg}{RTC\_PDD\_LockStatusReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Status\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga0681f481e213872418c16d5e012e5603}{RTC\_LR\_SRL\_MASK}) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a6255de23295c3295d12faf42f7399e0e}{RTC\_PDD\_LockStatusReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aa4d54aa845cbed8435ed063b294d64a0}\label{_r_t_c___p_d_d_8h_aa4d54aa845cbed8435ed063b294d64a0}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg}{RTC\_PDD\_LockTamperDetectReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Detect\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_LR\_TDL\_MASK) \(\backslash\)
  )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aa4d54aa845cbed8435ed063b294d64a0}{RTC\_PDD\_LockTamperDetectReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2818d87bf2c89150caafded71f7ae557}\label{_r_t_c___p_d_d_8h_a2818d87bf2c89150caafded71f7ae557}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg}{RTC\_PDD\_LockTamperEnableReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Enable\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_LR\_TEL\_MASK) \(\backslash\)
  )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2818d87bf2c89150caafded71f7ae557}{RTC\_PDD\_LockTamperEnableReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_abdee0a4509d3f3f3dd7503f6cb03d696}\label{_r_t_c___p_d_d_8h_abdee0a4509d3f3f3dd7503f6cb03d696}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg}{RTC\_PDD\_LockTamperInterruptReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Interrupt\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_LR\_TIL\_MASK) \(\backslash\)
  )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_abdee0a4509d3f3f3dd7503f6cb03d696}{RTC\_PDD\_LockTamperInterruptReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a4d02dfe2d1ac5b457aa9f9c21e1b8f15}\label{_r_t_c___p_d_d_8h_a4d02dfe2d1ac5b457aa9f9c21e1b8f15}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg}{RTC\_PDD\_LockTamperTimeSecondsReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Time\+Seconds\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)RTC\_LR\_TTSL\_MASK) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a4d02dfe2d1ac5b457aa9f9c21e1b8f15}{RTC\_PDD\_LockTamperTimeSecondsReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2cfcc219f1aa8dc02f971ecc6cb51d31}\label{_r_t_c___p_d_d_8h_a2cfcc219f1aa8dc02f971ecc6cb51d31}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg}{RTC\_PDD\_LockTamperTrimReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Tamper\+Trim\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
     (uint32\_t)(~(uint32\_t)RTC\_LR\_TTL\_MASK) \(\backslash\)
  )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2cfcc219f1aa8dc02f971ecc6cb51d31}{RTC\_PDD\_LockTamperTrimReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a1c3f99a246c2de3cae96ecb1d5fda91f}\label{_r_t_c___p_d_d_8h_a1c3f99a246c2de3cae96ecb1d5fda91f}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg}{RTC\_PDD\_LockTimeComensationReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Lock\+Time\+Comensation\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_LR\_REG(PeripheralBase) &= \(\backslash\)
       (uint32\_t)(~(uint32\_t)\hyperlink{group___r_t_c___register___masks_ga89f5d0ce94e7eb13bd961774fd440c0b}{RTC\_LR\_TCL\_MASK}) \(\backslash\)
    )
\end{DoxyCode}


The lock register is used to block write accesses to certain registers until the next V\+B\+A\+T\+\_\+\+P\+OR or software reset.\+Write accesses to a locked register are ignored and do not generate a bus error. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a1c3f99a246c2de3cae96ecb1d5fda91f}{RTC\_PDD\_LockTimeComensationReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ab384f783d6acffcf3ca2fbd99bd01430}\label{_r_t_c___p_d_d_8h_ab384f783d6acffcf3ca2fbd99bd01430}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED}{RTC\_PDD\_NOT\_ASSERTED}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+N\+O\+T\+\_\+\+A\+S\+S\+E\+R\+T\+ED~0U}

Pin is not asserted \mbox{\Hypertarget{_r_t_c___p_d_d_8h_af08ea06ba509408063e58c9034c1da9d}\label{_r_t_c___p_d_d_8h_af08ea06ba509408063e58c9034c1da9d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg}{RTC\_PDD\_ReadControlReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Control\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_CR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Control register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_af08ea06ba509408063e58c9034c1da9d}{RTC\_PDD\_ReadControlReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ae19e94746c7370a54d893b716c371c7e}\label{_r_t_c___p_d_d_8h_ae19e94746c7370a54d893b716c371c7e}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg}{RTC\_PDD\_ReadLockReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Lock\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Lock register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_ae19e94746c7370a54d893b716c371c7e}{RTC\_PDD\_ReadLockReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a7fe6c83828ac784abd4d5de65a2408e3}\label{_r_t_c___p_d_d_8h_a7fe6c83828ac784abd4d5de65a2408e3}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg}{RTC\_PDD\_ReadMonotonicCounterHighReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+High\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MCHR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Monotonic counter high register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+C\+HR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a7fe6c83828ac784abd4d5de65a2408e3}{RTC\_PDD\_ReadMonotonicCounterHighReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a30fe2d14dc6d7c908ad30e4840279a09}\label{_r_t_c___p_d_d_8h_a30fe2d14dc6d7c908ad30e4840279a09}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg}{RTC\_PDD\_ReadMonotonicCounterLowReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Counter\+Low\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MCLR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Monotonic counter low register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+C\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a30fe2d14dc6d7c908ad30e4840279a09}{RTC\_PDD\_ReadMonotonicCounterLowReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0c89348f4c6a03bbbdac79c5806c9447}\label{_r_t_c___p_d_d_8h_a0c89348f4c6a03bbbdac79c5806c9447}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg}{RTC\_PDD\_ReadMonotonicEnableReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Monotonic\+Enable\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MER\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Monotonic enable register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a0c89348f4c6a03bbbdac79c5806c9447}{RTC\_PDD\_ReadMonotonicEnableReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a3d50bcc8586f48ec668816f02b5335ad}\label{_r_t_c___p_d_d_8h_a3d50bcc8586f48ec668816f02b5335ad}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg}{RTC\_PDD\_ReadReadAccessReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Read\+Access\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Read access register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a3d50bcc8586f48ec668816f02b5335ad}{RTC\_PDD\_ReadReadAccessReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_adad1108af887779b61fedfc47bc127ee}\label{_r_t_c___p_d_d_8h_adad1108af887779b61fedfc47bc127ee}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg}{RTC\_PDD\_ReadStatusReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Status\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_SR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Status register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Use constants from group \char`\"{}\+Interrupt masks\char`\"{} for processing return value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_adad1108af887779b61fedfc47bc127ee}{RTC\_PDD\_ReadStatusReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_adccf8828ed9c6476de7e73fc9b148734}\label{_r_t_c___p_d_d_8h_adccf8828ed9c6476de7e73fc9b148734}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg}{RTC\_PDD\_ReadTamperDetectReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Detect\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TDR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Tamper detect register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+DR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_adccf8828ed9c6476de7e73fc9b148734}{RTC\_PDD\_ReadTamperDetectReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a7e90a265e9ca0efb22a1d63104fea96a}\label{_r_t_c___p_d_d_8h_a7e90a265e9ca0efb22a1d63104fea96a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg}{RTC\_PDD\_ReadTamperTimeSecondsReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Time\+Seconds\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TTSR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Tamper time seconds register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+T\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a7e90a265e9ca0efb22a1d63104fea96a}{RTC\_PDD\_ReadTamperTimeSecondsReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ab3d852c24e03416dd9d1a46035f8107f}\label{_r_t_c___p_d_d_8h_ab3d852c24e03416dd9d1a46035f8107f}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg}{RTC\_PDD\_ReadTamperTrimReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Tamper\+Trim\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TTR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Tamper trim register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+TR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_ab3d852c24e03416dd9d1a46035f8107f}{RTC\_PDD\_ReadTamperTrimReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a0ee012d50e404ede78f52b01af76fe4b}\label{_r_t_c___p_d_d_8h_a0ee012d50e404ede78f52b01af76fe4b}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg}{RTC\_PDD\_ReadTimeAlarmReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Alarm\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TAR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Time alarm register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a0ee012d50e404ede78f52b01af76fe4b}{RTC\_PDD\_ReadTimeAlarmReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a07f0a9a5f92353e131c8c29acf4a6dcf}\label{_r_t_c___p_d_d_8h_a07f0a9a5f92353e131c8c29acf4a6dcf}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg}{RTC\_PDD\_ReadTimeCompensationReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Compensation\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TCR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Time compensation register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result =
\hyperlink{_r_t_c___p_d_d_8h_a07f0a9a5f92353e131c8c29acf4a6dcf}{RTC\_PDD\_ReadTimeCompensationReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2e7aa88a1eca9a0a4a8a7230dcf230a6}\label{_r_t_c___p_d_d_8h_a2e7aa88a1eca9a0a4a8a7230dcf230a6}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg}{RTC\_PDD\_ReadTimePrescalerReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Prescaler\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TPR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Time prescaler register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+PR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_a2e7aa88a1eca9a0a4a8a7230dcf230a6}{RTC\_PDD\_ReadTimePrescalerReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aa2ba39ebe33db3dd9f62a96b7d6b186a}\label{_r_t_c___p_d_d_8h_aa2ba39ebe33db3dd9f62a96b7d6b186a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg}{RTC\_PDD\_ReadTimeSecondsReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Time\+Seconds\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TSR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Time seconds register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_aa2ba39ebe33db3dd9f62a96b7d6b186a}{RTC\_PDD\_ReadTimeSecondsReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ac66613996cca071936533d8706857de0}\label{_r_t_c___p_d_d_8h_ac66613996cca071936533d8706857de0}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg}{RTC\_PDD\_ReadWriteAccessReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Read\+Write\+Access\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) \(\backslash\)
  )
\end{DoxyCode}


Returns the content of the Write access register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a 32-\/bit value. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
uint32\_t result = \hyperlink{_r_t_c___p_d_d_8h_ac66613996cca071936533d8706857de0}{RTC\_PDD\_ReadWriteAccessReg}(<peripheral>\_BASE\_PTR);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_af6df0941f1d939cbb99ac4c44a7da686}\label{_r_t_c___p_d_d_8h_af6df0941f1d939cbb99ac4c44a7da686}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask}{RTC\_PDD\_SetRtcInterruptMask}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Interrupt\+Mask(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Mask }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_IER\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Mask) \(\backslash\)
  )
\end{DoxyCode}


Enables R\+TC interrupts defined by the Mask parameter. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Mask} & Imterrupt mask. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+I\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_af6df0941f1d939cbb99ac4c44a7da686}{RTC\_PDD\_SetRtcInterruptMask}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a207da0b8cb1b702423cfc7bfedbafc08}\label{_r_t_c___p_d_d_8h_a207da0b8cb1b702423cfc7bfedbafc08}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask}{RTC\_PDD\_SetRtcTamperInterruptMask}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Rtc\+Tamper\+Interrupt\+Mask(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Mask }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TIR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Mask) \(\backslash\)
  )
\end{DoxyCode}


Enables R\+TC tamper interrupts defined by the Mask parameter. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Mask} & Imterrupt mask. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+IR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a207da0b8cb1b702423cfc7bfedbafc08}{RTC\_PDD\_SetRtcTamperInterruptMask}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_ad3e9f2f0305ca3955e36f5b09a0dd2c9}\label{_r_t_c___p_d_d_8h_ad3e9f2f0305ca3955e36f5b09a0dd2c9}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State}{RTC\_PDD\_SetWakeUpPinState}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Set\+Wake\+Up\+Pin\+State(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State} }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_SR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(\hyperlink{group___x_f1__module_ga5d74787dedbc4e11c1ab15bf487e61f8}{State}) \(\backslash\)
  )
\end{DoxyCode}


Sets wake-\/up pin state. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em State} & Requested state. This parameter is of \char`\"{}\+Wake\+Up\+Pin\+State constants\char`\"{} type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_ad3e9f2f0305ca3955e36f5b09a0dd2c9}{RTC\_PDD\_SetWakeUpPinState}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_r_t_c___p_d_d_8h_a0e63cd9f06582f50609a7450f7072e21}{RTC\_PDD\_ASSERTED});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a46506be665e801685a1d8d68e38a053d}\label{_r_t_c___p_d_d_8h_a46506be665e801685a1d8d68e38a053d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT}{RTC\_PDD\_TAF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+A\+F\+\_\+\+I\+NT~\hyperlink{group___r_t_c___register___masks_ga8deec41a2823788375ed7b8b63870868}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+A\+F\+\_\+\+M\+A\+SK}}

Alarm interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_abb4f80ec20cc1734201d7cecd5260ace}\label{_r_t_c___p_d_d_8h_abb4f80ec20cc1734201d7cecd5260ace}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT}{RTC\_PDD\_TIF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+I\+F\+\_\+\+I\+NT~\hyperlink{group___r_t_c___register___masks_ga1efc73171f80fa079f4d3aec43f2faab}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+I\+F\+\_\+\+M\+A\+SK}}

Time invalid interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_a446474896e80e98138910c35f603437a}\label{_r_t_c___p_d_d_8h_a446474896e80e98138910c35f603437a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT}{RTC\_PDD\_TMF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+M\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+T\+M\+F\+\_\+\+M\+A\+SK}

Test mode tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_af91213da44685a41539f7f391cf7be9a}\label{_r_t_c___p_d_d_8h_af91213da44685a41539f7f391cf7be9a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT}{RTC\_PDD\_TOF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+O\+F\+\_\+\+I\+NT~\hyperlink{group___r_t_c___register___masks_gabadca56816c485ca12134cd54a40c010}{R\+T\+C\+\_\+\+S\+R\+\_\+\+T\+O\+F\+\_\+\+M\+A\+SK}}

Timer overflow interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_aaef84c5a6ca4b9713e11364b39decc3a}\label{_r_t_c___p_d_d_8h_aaef84c5a6ca4b9713e11364b39decc3a}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT}{RTC\_PDD\_TTF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+T\+T\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+T\+T\+F\+\_\+\+M\+A\+SK}

Temperature tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_aa9f4482580fbc9919e18af00e8241d86}\label{_r_t_c___p_d_d_8h_aa9f4482580fbc9919e18af00e8241d86}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT}{RTC\_PDD\_VTF\_INT}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+V\+T\+F\+\_\+\+I\+NT~R\+T\+C\+\_\+\+T\+D\+R\+\_\+\+V\+T\+F\+\_\+\+M\+A\+SK}

Volatge tamper interrupt mask \mbox{\Hypertarget{_r_t_c___p_d_d_8h_a5f7a9d9f496bbb5ca0097bc043343c93}\label{_r_t_c___p_d_d_8h_a5f7a9d9f496bbb5ca0097bc043343c93}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg}{RTC\_PDD\_WriteControlReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Control\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_CR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Control register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Control register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a5f7a9d9f496bbb5ca0097bc043343c93}{RTC\_PDD\_WriteControlReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aef472e29a6b17d294c59d1c3034b18c1}\label{_r_t_c___p_d_d_8h_aef472e29a6b17d294c59d1c3034b18c1}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg}{RTC\_PDD\_WriteLockReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Lock\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_LR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Lock register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Lock register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aef472e29a6b17d294c59d1c3034b18c1}{RTC\_PDD\_WriteLockReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a2df7f7b754db931d38279b3c5ffe0bb4}\label{_r_t_c___p_d_d_8h_a2df7f7b754db931d38279b3c5ffe0bb4}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg}{RTC\_PDD\_WriteMonotonicCounterHigReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Hig\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MCHR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Monotonic counter high register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Monotonic counter high register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+C\+HR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a2df7f7b754db931d38279b3c5ffe0bb4}{RTC\_PDD\_WriteMonotonicCounterHigReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a054e742b4e5e61613b13a7b671f5d230}\label{_r_t_c___p_d_d_8h_a054e742b4e5e61613b13a7b671f5d230}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg}{RTC\_PDD\_WriteMonotonicCounterLowgReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Counter\+Lowg\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MCLR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Monotonic counter low register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Monotonic counter low register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+C\+LR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a054e742b4e5e61613b13a7b671f5d230}{RTC\_PDD\_WriteMonotonicCounterLowgReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a9b2bc03b643c34aa2d838f4940efced1}\label{_r_t_c___p_d_d_8h_a9b2bc03b643c34aa2d838f4940efced1}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg}{RTC\_PDD\_WriteMonotonicEnableReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Monotonic\+Enable\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_MER\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Monotonic enable register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Monotonic enable register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+M\+ER. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a9b2bc03b643c34aa2d838f4940efced1}{RTC\_PDD\_WriteMonotonicEnableReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_add82e4e48e503fcf4251a184ab909ddb}\label{_r_t_c___p_d_d_8h_add82e4e48e503fcf4251a184ab909ddb}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg}{RTC\_PDD\_WriteReadAccessReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Read\+Access\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_RAR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Read access register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Read access register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+R\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_add82e4e48e503fcf4251a184ab909ddb}{RTC\_PDD\_WriteReadAccessReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a3c4cc08551630f3fd29023fb567f585e}\label{_r_t_c___p_d_d_8h_a3c4cc08551630f3fd29023fb567f585e}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg}{RTC\_PDD\_WriteStatusReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Status\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
      RTC\_SR\_REG(PeripheralBase) = \(\backslash\)
       (uint32\_t)(Value) \(\backslash\)
    )
\end{DoxyCode}


Writes value to the Status register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Status register. Use constants from group \char`\"{}\+Interrupt masks\char`\"{}. This parameter is 32 bits wide. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a3c4cc08551630f3fd29023fb567f585e}{RTC\_PDD\_WriteStatusReg}(<peripheral>\_BASE\_PTR, 
      \hyperlink{_r_t_c___p_d_d_8h_a46506be665e801685a1d8d68e38a053d}{RTC\_PDD\_TAF\_INT});
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aeaac5e04ba0273608be155218f75a343}\label{_r_t_c___p_d_d_8h_aeaac5e04ba0273608be155218f75a343}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg}{RTC\_PDD\_WriteTamperDetectReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Detect\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TDR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Tamper detect register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Tamper detect register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+DR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aeaac5e04ba0273608be155218f75a343}{RTC\_PDD\_WriteTamperDetectReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_aafa78b3394ecc51ebc05d31b6b670c05}\label{_r_t_c___p_d_d_8h_aafa78b3394ecc51ebc05d31b6b670c05}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg}{RTC\_PDD\_WriteTamperTrimReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Tamper\+Trim\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TTR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Tamper trim register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Tamper trim register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+TR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_aafa78b3394ecc51ebc05d31b6b670c05}{RTC\_PDD\_WriteTamperTrimReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a4bec7545b99e206c42d8673e0705de6d}\label{_r_t_c___p_d_d_8h_a4bec7545b99e206c42d8673e0705de6d}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg}{RTC\_PDD\_WriteTimeAlarmReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Alarm\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TAR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Time alarm register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Time alarm register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a4bec7545b99e206c42d8673e0705de6d}{RTC\_PDD\_WriteTimeAlarmReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_afcf1d27bf8728764eb2ad52bd0576c12}\label{_r_t_c___p_d_d_8h_afcf1d27bf8728764eb2ad52bd0576c12}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg}{RTC\_PDD\_WriteTimeCompensationReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Compensation\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TCR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Time compensation register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Time compensation register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+CR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_afcf1d27bf8728764eb2ad52bd0576c12}{RTC\_PDD\_WriteTimeCompensationReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a54b9f51c8504efe26e8037a7839e074b}\label{_r_t_c___p_d_d_8h_a54b9f51c8504efe26e8037a7839e074b}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg}{RTC\_PDD\_WriteTimePrescalerReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Prescaler\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TPR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Time prescaler register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Time prescaler register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+PR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a54b9f51c8504efe26e8037a7839e074b}{RTC\_PDD\_WriteTimePrescalerReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a3c87ce278c703cc5cdf0cf5a657f6f16}\label{_r_t_c___p_d_d_8h_a3c87ce278c703cc5cdf0cf5a657f6f16}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg}{RTC\_PDD\_WriteTimeSecondsReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Time\+Seconds\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_TSR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Time seconds register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Time seconds register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+T\+SR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a3c87ce278c703cc5cdf0cf5a657f6f16}{RTC\_PDD\_WriteTimeSecondsReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{_r_t_c___p_d_d_8h_a80c42e1509ae82a4489512f9ecaa9676}\label{_r_t_c___p_d_d_8h_a80c42e1509ae82a4489512f9ecaa9676}} 
\index{R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}!R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg}}
\index{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg@{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg}!R\+T\+C\+\_\+\+P\+D\+D.\+h@{R\+T\+C\+\_\+\+P\+D\+D.\+h}}
\subsubsection{\texorpdfstring{R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg}{RTC\_PDD\_WriteWriteAccessReg}}
{\footnotesize\ttfamily \#define R\+T\+C\+\_\+\+P\+D\+D\+\_\+\+Write\+Write\+Access\+Reg(\begin{DoxyParamCaption}\item[{}]{Peripheral\+Base,  }\item[{}]{Value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
( \(\backslash\)
    RTC\_WAR\_REG(PeripheralBase) = \(\backslash\)
     (uint32\_t)(Value) \(\backslash\)
  )
\end{DoxyCode}


Writes value to the Write access register. 


\begin{DoxyParams}{Parameters}
{\em Peripheral\+Base} & Pointer to a peripheral registers structure (peripheral base address). You can use the constant defined in the registers definition header file ($<$peripheral$>$\+\_\+\+B\+A\+S\+E\+\_\+\+P\+TR) or the constant defined in the peripheral initialization component header file ($<$component\+\_\+name$>$\+\_\+\+D\+E\+V\+I\+CE). \\
\hline
{\em Value} & Value written to the Write access register. This parameter is a 32-\/bit value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a value of void type. 
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The macro accesses the following registers\+: R\+T\+C\+\_\+\+W\+AR. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{_r_t_c___p_d_d_8h_a80c42e1509ae82a4489512f9ecaa9676}{RTC\_PDD\_WriteWriteAccessReg}(<peripheral>\_BASE\_PTR, 1);
\end{DoxyCode}
 
\end{DoxyParagraph}
